---
title: "Unofficial Rcpp API Documentation"
output:
  pdf_document: default
  html_document: default
date: '`r format(Sys.time(), "%F %T %z")`'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

**Warning: This post is a work in progress. It will periodically be updated
as time permits.**

# Introduction

The following **unofficial** API documentation for [Rcpp](http://rcpp.org) is based off some
personal notes and teaching materials that I have prepared over the years of
working with Rcpp. I've attempted to reformat the notes in the form of [Armadillo's API](http://arma.sourceforge.net/docs.html),
which I think are some of the best documentation out there for a C++ matrix library.
At some point, when the documentation becomes a bit more stable or if there is 
larger contributor interest, I will likely attempt to merge this into the Rcpp 
project so that a docs subdomain could hopefully be added to <http://rcpp.org>.

Please note: The post is written using [RMarkdown](http://rmarkdown.rstudio.com)
for maximum flexibility.

# API Documentation for Rcpp 0.12.9

## Preamble

- The goal of the API documentations are to provide a public facing concise 
  view of Rcpp features. As a result, the documentation will be somewhat long.
  To help navigate the documentation, it has been split into different section.
  Furthermore, one should use the built in search functionality to search text
  for keywords using either `CNTRL` + `F` on Windows and Linux or `CMD` + `F` on
  macOS. 

- Presently, any contribution to this document may be down by a [pull request
  (PRs)](https://github.com/coatless/rcpp-api/pulls) on GitHub.

- Please report any bugs to the [Rcpp Core Team](https://github.com/rcppcore/rcpp/issues).
 
## Overview

- [Vector, Matrix, List, DataFrame](#vmld)
- [Member functions](#member-functions)
    - [Operators](#ops)
    - [Dimensional Information](#dim-info)
    - [Element Access](#elem-access)
        - [Position Access](#position-access)
        - [Categorical Access](#categorical-access)
        - [Logical Access](#logical-access)
    - [Subset Views](#subview)
    - [Iterators](#iterators)
    - [STL-style container functions](#stl-functions)
    - [Static Member Functions](#static-members)
- [Sugar](#sugar)
    - [Statistical Distributions](#stat-dist)
- Environment, Function, Language
- XPtr
- S4 classes / modules

------

## Vector, Matrix, List, and DataFrame Classes

|                                                                 |                    |
|:----------------------------------------------------------------|:-------------------|
|  [Vector<*RTYPE*>, NumericVector, IntegerVector, ...](#vector)  | Vector class       |
|  [Matrix<*RTYPE*>, NumericMatrix, IntegerMatrix, ...](#matrix)  | Matrix class       |
|  [List](#list)                                                  | List typedef       |
|  [DataFrame](#dataframe)                                        | Data frame class   |
|  [RObject](#robject)                                            | RObject class      |

## Member functions

|                                                  |                                                                    |
|:-------------------------------------------------|:-------------------------------------------------------------------|
|  [Operators](#ops)                               | Mathematical (add, subtract, etc) and logical (inequalities)       |
|  [Dimensional Information](#dim-info)            | Size attribute information                                         |
|  [Element Access](#elem-access)                  | Retrieving element values with and without bounds check            |
|  [Subset Views](#subview)                        | Subset data structures                                             |
|  [Iterators](#iterators)                         | Random access iterators                                            |
|  [STL-style Container Functions](#stl-functions) | Standard Library styled functions                                  |
|  [Static Member Functions](#static-members)      | Set of member functions persistant across instances                |

## Sugar

**[Logical Operations](#sugar-logic-ops)**

|                              |                            |
|:-----------------------------|:---------------------------|
| [`ifelse`](#ifelse)          | Vectorized If-else         |
| [`is_false`](#isbool)        | Is Value False?            |
| [`is_true`](#isbool)         | Is Value True?             |
| [`any`](#any)                | At Least One Value is True |
| [`all`](#all)                | All Values Must be True    |

**[Complex Operators](#sugar-complex-ops)**

|                               |                                    |
|:------------------------------|:-----------------------------------|
| [`Re`](#complex-number)       | Real Values of Complex Number      |
| [`Im`](#complex-number)       | Imaginary Values of Complex Number |
| [`Mod`](#complex-modulus)     | Modulus (r)                        |
| [`Arg`](#complex-arg)         | Arg (theta)                        |
| [`Conj`](#complex-conjugate)  | Complex Conjugate                  |

**[Data Operations](#sugar-data-ops)**

|                             |                               |
|:----------------------------|:------------------------------|
| [`head`](#first-last-elems) | View the First _n_ Values     |
| [`tail`](#first-last-elems) | View the Last _n_ Values      |
| [`abs`](#abs)               | Absolute Value                |
| [`sqrt`](#sqrt)             | Square Root                   |
| [`pow`](#pow)               | Raise to the _n_^th^ Power    |
| [`sum`](#sum)               | Summation                     |
| [`sign`](#sign)             | Extract the Sign of Values    |
| [`diff`](#diff)             | Lagged Difference             |
| [`cumsum`](#carth)          | Cumulative Sum                |
| [`cumprod`](#carth)         | Cumulative Product            |
| [`cummin`](#cext)           | Cumulative Minimum            |
| [`cummax`](#cext)           | Cumulative Maximum            |
| [`sin`](#trig)              | Sine                          |
| [`cos`](#trig)              | Cosine                        |
| [`tan`](#trig)              | Tangent                       |
| [`asin`](#trig)             | Arc Sine                      |
| [`acos`](#trig)             | Arc Cosine                    |
| [`atan`](#trig)             | Arc Tangent                   |
| [`sinh`](#trig)             | Hyperbolic Sine               |
| [`cosh`](#trig)             | Hyperbolic Cosine             |
| [`tanh`](#trig)             | Hyperbolic Tangent            |
| [`log`](#logexp)            | Natural Logarithms            |
| [`exp`](#logexp)            | Expoential                    |
| [`log10`](#logexp)          | Base 10 Logarithm             |
| [`log1p`](#logexp)          | Natural Logarithm $log(1+x)$  |
| [`expm1`](#logexp)          | $\exp(x) - 1$                 |


**[Rounding of Numbers](#sugar-rounding)**

|                                    |                                               |
|:-----------------------------------|:----------------------------------------------|
| [`ceiling`](#ceil),[`ceil`](#ceil) | Smallest integer greater than or equal to x   |
| [`trunc`](#trunc)                  | Truncates the values in x toward 0            |
| [`floor`](#floor)                  | Largest integer less than or equal to x       | 
| [`round`](#round)                  | Round values to specified decimal place       |
| [`signif`](#signif)                | Rounds values to number of significant digits |


**[Finite, Infinite and NaN Detection](#sugar-nan)**

|                                    |                                            |
|:-----------------------------------|:-------------------------------------------|
| [`pre-defined`](#nanconstants)     | Pre-defined NA/NaN/Inf Constants           |
| [`is_na`](#missingness)            | Detects if values are missing              |
| [`is_nan`](#missingness)           | Detects if values are not a number (`NaN`) |
| [`is_finite`](#finite)             | Detects if value is finite                 |
| [`is_infinite`](#finite)           | Detects if value is infinite               |
| [`na_omit`](#na-omit)              | Remove `NA` and `NaN` values               |
| [`noNA`](#nona)                    | Assert that the object is `NA` free        |


**[The Apply Family](#sugar-apply)**

|                       |                                                                 |
|:----------------------|:----------------------------------------------------------------|
| [`sapply`](#sapply)   | Apply a function to one input and store results in vector       |
| [`lapply`](#lapply)   | Apply a function to one input and store results in list         |
| [`mapply`](#mapply)   | Apply a function to multiple inputs and store results in vector |

**[Special Functions of Mathematics](#sugar-special-math)**

|                              |                            |
|:-----------------------------|:---------------------------|
| [`factorial`](#factorials)   | Factorial                  |
| [`lfactorial`](#factorials)  | Factorial Logarithm        |
| [`choose`](#combinatorics)   | Combination                |
| [`lchoose`](#combinatorics)  | Combination Logarithm      |
| [`beta`](#beta)              | Beta Function              |
| [`lbeta`](#beta)             | Natural Log Beta Function  |
| [`gamma`](#gamma)            | Gamma Function             |
| [`lgamma`](#gamma)           | Natural Log Gamma Function |
| [`psigamma`](#gamma-deriv)   | General Gamma Derivative   |
| [`digamma`](#gamma-deriv)    | Second Gamma Derivative    |
| [`trigamma`](#gamma-deriv)   | Third Gamma Derivative     |
| [`tetragamma`](#gamma-deriv) | Fourth Gamma Derivative    |
| [`pentagamma`](#gamma-deriv) | Fifth Gamma Derivative     |

**[Statistical Summaries](#sugar-stats)**

|                      |                      |
|:---------------------|:---------------------|
| [`min`](#minmax)     | Minimum Value        |
| [`max`](#minmax)     | Maximum Value        |
| [`range`](#range)    | Range                |
| [`mean`](#mean)      | Mean Value           |
| [`median`](#median)  | Median Value         |
| [`var`](#var)        | Variance             |
| [`sd`](#var)         | Standard Deviation   |

**[Special Operators](#sugar-special-ops)**

|                        |                                      |
|:-----------------------|:-------------------------------------|
| [`rev`](#rev)          | Reverse ordering of a vector         |
| [`pmax`](#pext)        | Parallel maximum value               |
| [`pmin`](#pext)        | Parallel minimum value               |
| [`clamp`](#clamp)      | Values between a minimum and maximum |
| [`which_max`](#which)  | Index of the maximum value           |
| [`which_min`](#which)  | Index of the minimum value           |


**[Uniqueness Operators](#sugar-unique-ops)**

|                               |                                                                |
|:------------------------------|:---------------------------------------------------------------|
| [`match`](#match)             | Find indices of the first value in a separate vector           |
| [`self_match`](#self-match)   | Find indices of the first occurrence of each value in a vector |
| [`in`](#in)                   | Determine if a match was located for each element of _A_ in _B_|
| [`unique`](#unique)           | Obtain the unique values                                       |
| [`duplicated`](#unique)       | Obtain a logical vector indicating the duplicate values        |
| [`sort_unique`](#sort-unique) | Obtain the unique values and sort them                         |
| [`table`](#table)             | Create a frequency table of occurrences                        |


**[Set Operations](#sugar-set-ops)**

|                           |                                          |
|:--------------------------|:-----------------------------------------|
| [`setequal`](#setequal)   | Equality of Set Values                   |
| [`intersect`](#intersect) | Intersection of Set Values               |
| [`union_`](#union)        | Union of Set Values                      |
| [`setdiff`](#setdiff)     | Asymmetric Difference of Set Values      |


**[Matrix Operations](#sugar-matrix-ops)**

|                            |                                                |
|:---------------------------|:-----------------------------------------------|
| [`colSums`](#matrix-sum)   | Column Sums of a Matrix                        |
| [`rowSums`](#matrix-sum)   | Row Sums of a Matrix                           |
| [`colMeans`](#matrix-mean) | Column Means of a Matrix                       |
| [`rowMeans`](#matrix-mean) | Row Means of a Matrix                          |
| [`outer`](#outer)          | Outer Product of Arrays on a Function          |
| [`lower_tri`](#tri-mat)    | Extract the _Lower_ Triangle Part of a Matrix  |
| [`upper_tri`](#tri-mat)    | Extract the _Upper_ Triangle Part of a Matrix  |
| [`diag`](#diag)            | Extract the Diagonal Portion of a Matrix       |
| [`row`](#idx-mat)          | Create a matrix of Row Indexes                 |
| [`col`](#idx-mat)          | Create a matrix of Column Indexes              |


**[Object Creation](#sugar-object-creation)**

|                     |                                                |
|:--------------------|:-----------------------------------------------|
| [`cbind`](#cbind)   | Create matrix by combing column vectors        |
| [`seq_along`](#seq) | Generate an R index sequence given a vector    |
| [`seq_len`](#seq)   | Generate an R index sequence given an integer  |
| [`rep`](#rep)       | Replicate vector $N$ times                     |
| [`rep_each`](#rep)  | Replicate each element in line $N$ times       |
| [`rep_len`](#rep)   | Replicate values until vector is of length $N$ |

**[String Operations](#sugar-string-ops)**

|                         |                                                |
|:------------------------|:-----------------------------------------------|
| [`collapse`](#collapse) | Collapse multiple strings into one string      |




**[Statistical Distributions](#stat-dist)**

**[Discrete Distributions](#discrete-dist)**

|                                   |                        |
|-----------------------------------|------------------------|
|  [`p/d/q/rbinom`](#bin-dist)      | Binomial               |
|  [`p/d/q/rgeom`](#geo-dist)       | Geometric              |
|  [`p/d/q/rhyper`](#hypergeo-dist) | Hypergeometric         |
|  [`p/d/q/rnbinom`](#negbin-dist)  | Negative Binomial      |
|  [`p/d/q/rpois`](#pois-dist)      | Poisson                |
|  [`p/d/q/rwilcox`](#wilcox-dist)  | Wilcoxon               |
|  [`p/d/q/rsignrank`](#signed-dist)| Wilcoxon Signed Rank   |

**[Continuous Distributions](#continuous-dist)**

|                                    |                              |
|------------------------------------|------------------------------|
|  [`p/d/q/rbeta`](#beta-dist)       | Beta                         |
|  [`p/d/q/rcauchy`](#cauchy-dist)   | Cauchy                       |
|  [`p/d/q/rchisq`](#chisquare-dist) | Chi-square                   |
|  [`p/d/qnchisq`](#nchisquare-dist) | Non-central Chi-square       |
|  [`p/d/q/rexp`](#exp-dist)         | Exponential                  |
|  [`p/d/q/rf`](#f-dist)             | F                            |
|  [`p/d/qnf`](#nf-dist)             | Non-central F                |
|  [`p/d/q/rgamma`](#gamma-dist)     | Gamma                        |
|  [`p/d/q/rnorm`](#normal-dist)     | Normal                       |
|  [`p/d/q/rlnorm`](#lognormal-dist) | Log Normal                   |
|  [`p/d/q/rlogis`](#logistic-dist)  | Logistic                     |
|  [`p/d/q/rt`](#t-dist)             | Student's T                  |
|  [`p/d/q/runif`](#unif-dist)       | Uniform                      |
|  [`p/d/q/rweibull`](#weibull-dist) | Weibull                      |

## Vector, Matrix, List, and DataFrame Classes {#vmld}

### Vector {#vector}

- The templated `Vector` class is a one dimensional array-like structure 
  providing storage for homogenous data types, with an 
  interface similar to that of `std::vector`. Being an implementation of 
  [policy-based design](https://en.wikipedia.org/wiki/Policy-based_design), 
  much of the behavior of `Vector` is determined by the policy classes it 
  inherits from 
  
    - `RObjectMethods` 
    - `StoragePolicy` 
    - `SlotProxyPolicy` 
    - `AttributeProxyPolicy` 
    - `NamesProxyPolicy` 
    
    as well as the CRTP base class `VectorBase`. This type is instantiated as 
    `Vector<RTYPE>`, where `RTYPE` is one of the following valid `SEXPTYPE`s: 
    
    - `REALSXP` 
    - `INTSXP` 
    - `CPLXSXP` 
    - `LGLSXP` 
    - `STRSXP` 
    - `VECSXP`
    - `RAWSXP`
    - `EXPRSXP`

- For convenience, the following [`typedefs` have been defined](https://github.com/RcppCore/Rcpp/blob/6f81b4684481dbd9bb554dd95e66725fc3b63a8c/inst/include/Rcpp/vector/instantiation.h#L27-L38) in the `Rcpp` namespace: 

    - `NumericVector`    = `Vector<REALSXP>`
    - `DoubleVector`     = `Vector<REALSXP>`
    - `RawVector`        = `Vector<RAWSXP>`
    - `IntegerVector`    = `Vector<INTSXP>`
    - `ComplexVector`    = `Vector<CPLXSXP>`
    - `LogicalVector`    = `Vector<LGLSXP>`
    - `CharacterVector`  = `Vector<STRSXP>` 
    - `StringVector`     = `Vector<STRSXP>` 
    - `GenericVector`    = `Vector<VECSXP>` 
    - `List`             = `Vector<VECSXP>`
    - `ExpressionVector` = `Vector<EXPRSXP>`

- Within this documentation, the default type used will be `NumericVector` unless
another data type is required to show a specific feature.

- Constructors:
    - `Vector()`
    - `Vector(SEXP x)`
    - `Vector(const int &size, const stored_type &u)`
    - `Vector(const std::string &st)`
    - `Vector(const char *st)`
    - `Vector(const Vector &other)`
    - `Vector(const int &size)`
 	- `Vector(const Dimension &dims)`
    - `Vector(const Dimension &dims, const U &u)`
    - `Vector(const Vector &other)`

- By default, the vectors constructed from dimensions will always be 
  initialized with all entries being zero (`0`) or an empty string (`""`).

- For the majority of cases, the interface being used is that of the R to C++
  interface that relies upon the `Vector(SEXP x)` constructor, which establishes
  a **pointer** to the underlying data. That is, the `Vector` object _points_ to
  the memory location of the `SEXP` R object in order to avoid copying the data
  into _C++_. The only exception to this rule is if the data passed is of a
  different type in which case a deep copy is performed _before_ a pointer is
  established. For example, if `numeric()` data is passed to `NumericVector`
  the correct handoff occurs. However, if `integer()` data were to be passed to
  a `NumericVector` a `clone()` would be made to type `numeric()` which has its
  pointer then assigned to the `NumericMatrix`.

- Examples:

```{Rcpp rcpp_vector_ctor}
SEXP A;
NumericVector B(A); // from a SEXP

// create a vector of length 5 filled with 0
NumericVector C(5);
// Output: 0 0 0 0 0

// construct a filled vector of size 3 with 2.0
NumericVector D = NumericVector(3, 2.0); 
// Output: 2 2 2

// initialize empty numeric vector of size 5
NumericVector D2 = no_init(5);

// fill vector with 3.0
D2.fill(3.0);
// Output: 3 3 3 3 3

// cloning (deep copy)
NumericVector E = clone(D);
// Output: 2 2 2
```

- See also:
    - [Vector Class doxygen documentation](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1Vector.html)
    - [`typedef` at cppreference.com](http://en.cppreference.com/w/cpp/language/typedef)

------
 
### Matrix {#matrix}

- The main class for matrices is the templated `Matrix` class, which derives from
  a combination of both the `Vector` and `MatrixBase` types. Like the `Vector` 
  class, `Matrix` uses the policy-based design pattern to manage the lifetime of 
  its undelying `SEXP` via the template parameter `StoragePolicy`, which 
  uses the `PreserveStorage` policy class by default. Matrices are  
  instantiated as `Matrix<RTYPE>`, where the value `RTYPE` is one of the 
  following `SEXPTYPE`s: 
  
    - `REALSXP` 
    - `INTSXP` 
    - `CPLXSXP` 
    - `LGLSXP` 
    - `STRSXP`
    - `VECSXP` 
    - `RAWSXP`
    - `EXPRSXP`


- For convenience, the following [`typedefs` have been defined](https://github.com/RcppCore/Rcpp/blob/6f81b4684481dbd9bb554dd95e66725fc3b63a8c/inst/include/Rcpp/vector/instantiation.h#L40-L50) in the `Rcpp` 
  namespace: 
  
    - `NumericMatrix`    = `Matrix<REALSXP>`
    - `RawMatrix`        = `Matrix<RAWSXP>`
    - `IntegerMatrix`    = `Matrix<INTSXP>`
    - `ComplexMatrix`    = `Matrix<CPLXSXP>`
    - `LogicalMatrix`    = `Matrix<LGLSXP>`
    - `CharacterMatrix`  = `Matrix<STRSXP>` 
    - `StringMatrix`     = `Matrix<STRSXP>` 
    - `GenericMatrix`    = `Matrix<VECSXP>` 
    - `ListMatrix`       = `Matrix<VECSXP>` 
    - `ExpressionMatrix` = `Matrix<EXPRSXP>`


- Within this documentation, the default type used will be `NumericMatrix` unless
another data type is required to show a specific feature. 

- Constructors:
    - `Matrix()` 
    - `Matrix(SEXP x)`
    - `Matrix(const int& nrows_, const int& ncols)` 
    - `Matrix(const int& nrows_, const int& ncols, Iterator start)` 
    - `Matrix(const int& n)`
    - `Matrix(const Matrix& other)` 

- By default, the matrices constructed from dimensions will always be 
  initialized with all entries being zero (`0`) or empty strings (`""`)

- For the majority of cases, the interface being used is that of the R to C++
  interface that relies upon the `Matrix(SEXP x)` constructor, which establishes
  a **pointer** to the underlying data. That is, the `Vector` object _points_ to
  the memory location of the `SEXP` R object in order to avoid copying the data
  into _C++_. The only exception to this rule is if the data passed is of a
  different type in which case a deep copy is performed _before_ a pointer is
  established. For example, if `numeric()` data is passed to `NumericMatrix`
  the correct handoff occurs. However, if `integer()` data were to be passed to
  a `NumericMatrix` a `clone()` would be made to type `numeric()` which has its
  pointer then assigned to the `NumericMatrix`.

- Examples:

```{Rcpp rcpp_matrix_ctor}
SEXP A;
NumericMatrix B(A); // from a SEXP

// create a square matrix (all elements set to 0.0)
NumericMatrix C(2);
// Output:
// 0 0
// 0 0

// of a given size (all elements set to 0.0)
NumericMatrix D(2, 3);
// Output:
// 0 0 0
// 0 0 0

// of a given size with dimensions (all elements set to 0.0)
NumericMatrix D2(Dimension(3, 2));
// Output:
// 0 0
// 0 0
// 0 0

// initialize empty numeric matrix
NumericMatrix D3 = no_init(2, 1);

// fill matrix with 3.0
D3.fill(3.0);
// Output:
// 3.0
// 3.0

// fill matrix using a vector
NumericVector E = NumericVector(15, 2.0); 
NumericMatrix F = NumericMatrix(3, 5, E.begin());
// Output:
// 2 2 2 2 2
// 2 2 2 2 2
// 2 2 2 2 2

// cloning (explicit deep copy)
NumericMatrix G = clone(F);
```

- See also:
    - [`Matrix` Class doxygen documentation](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1Matrix.html)
    - [`typedef` at cppreference.com](http://en.cppreference.com/w/cpp/language/typedef)

### List {#list}

- The `List` data structure is a `typedef` of templated `Vector` class based
  on the `RTYPE` of `VECSXP` that provides heterogenous storage class. As
  a result, the `List` class acts as a generic storage object that can
  simultaneously hold multiple different `RTYPE` structures.
  
- Constructors:
    - `List()`
    - `List(SEXP x)`
    - `List(const int &size, const stored_type &u)`
    - `List(const std::string &st)`
    - `List(const char *st)`
    - `List(const Vector &other)`
    - `List(const int &size)`
 	- `List(const Dimension &dims)`
    - `List(const Dimension &dims, const U &u)`
    - `List(const Vector &other)`

- Unlike the `Vector` class, the `List` constructed from dimensions will have a
  `NULL` value set for each element unless a value is otherwise assigned.
  
- Examples:

```{Rcpp rcpp_list_ctor}
SEXP A;
List B(A); // from a SEXP

// create an empty List of size 2 
List C(2);
// Output: 
// [[1]]
// NULL
// [[2]]
// NULL

// construct List of size 3 with one element containing 2.0
List D = List(3, 2.0); 
// Output: 
// [[1]]
// [1] 2
// [[2]]
// [1] 2
// [[3]]
// [1] 2

// initialize empty list of size 3
List D2 = no_init(3);

// fill list one element equal to 3.0
D2.fill(3.0);
// Output: 
// [[1]]
// [1] 3
// [[2]]
// [1] 3
// [[3]]
// [1] 3

// cloning (deep copy)
List E = clone(D);
// Output: 
// [[1]]
// [1] 2
// [[2]]
// [1] 2
// [[3]]
// [1] 2


// Create a named list
NumericVector F = NumericVector::create(1.2, 3.5);
CharacterVector G = CharacterVector::create("a", "b", "c");
LogicalVector H = LogicalVector::create(true, false, false, true);

// Create named list
List F = List::create(Named("v1") = F,
                      Named("v2") = G,
                          _["v3"] = H); // Shorthand for Named("V3")
// Output:
// $v1
// [1] 1.2 3.5
// $v2
// [1] "a" "b" "c"
// $v3
// [1]  TRUE FALSE FALSE  TRUE
```

- See also:
    - [`Vector`](#vector)
    - [Vector Class doxygen documentation](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1Vector.html)
    - [`typedef` at cppreference.com](http://en.cppreference.com/w/cpp/language/typedef)

### DataFrame {#dataframe}

- The `DataFrame` data structure is a typedef of the `DataFrame_Impl` class,
  which is a special extension of the templated `Vector` class
  that allows for a collection of heterogenous `Vector`'s of the same length.
  As the crux of the implementation of is
  [policy-based design](https://en.wikipedia.org/wiki/Policy-based_design) focused, 
  much of the behavior of `DataFrame` is determined by the policy classes it 
  inherits from 
  
    - `RObjectMethods` 
    - `StoragePolicy` 
    - `SlotProxyPolicy` 
    - `AttributeProxyPolicy` 
    - `NamesProxyPolicy` 
    
    as well as the CRTP base class `VectorBase`.

- Constructors:

 	- `DataFrame()`
 	- `DataFrame(SEXP x)`
 	- `DataFrame(const DataFrame &other)`
 	- `DataFrame(const T &obj)`

- **Caveat:** All `DataFrame` columns _must_ be named. Failure to name the columns
  will result in the run time error of:
  
  > not compatible with STRSXP
  
  since Rcpp uses an internal call to _R_ to create the `DataFrame`. 

- Examples:

```{Rcpp rcpp_dataframe_ctor}
SEXP A;
DataFrame B(A); // from a SEXP

// Create Data
NumericVector C = NumericVector::create(5.8, 9.1, 3.2); 
CharacterVector D = CharacterVector::create("a", "b", "c");
LogicalVector E = LogicalVector::create(true, false, false);

// Create a new dataframe
DataFrame G = DataFrame::create(Named("C") = C,
                                    _["D"] = D, // shorthand for Named("D")
                                Named("E") = E);
```

- See also:
    - [`Vector`](#vector)
    - [DataFrame `typedef`](http://dirk.eddelbuettel.com/code/rcpp/html/DataFrame_8h.html)
    - [`DataFrame_Impl` class](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1DataFrame__Impl.html)
    - [`typedef` at cppreference.com](http://en.cppreference.com/w/cpp/language/typedef)


### RObject {#robject}

- The `RObject` data structure is a typedef of the `RObject_Impl` class. Principally,
  the class can be viewed as the glue of Rcpp due to [policy-based design](https://en.wikipedia.org/wiki/Policy-based_design)
  principles. In turn, the `RObject` class really acts as a "shell" that stores
  properties of the following policies:

    - `PreserveStorage`: Member functions that provide the `SEXP` _R_ object
       alongside ways to modify and update the object.
    - `SlotProxyPolicy`: Member functions related to _only_ manipulating S4 
       objects.
    - `AttributeProxyPolicy`: Member functions that modify attribute information
       of the _R_ object.
    - `RObjectMethods`: Member functions that provide descriptors of the _R_ 
       object such as type, object oriented programming (S3/S4) system, and 
       `NULL` status.
    
- Constructors:

 	- `RObject()`
 	- `RObject(const RObject &other)`
 	- `RObject(const GenericProxy<Proxy> &proxy)`

- Examples:

```{Rcpp robject_example}
// Extract attribute information via AttributeProxyPolicy
RObject A;
RObject B = A.attr("dim");
```

- See also:
    - [Modern C++ Design](http://en.wikipedia.org/wiki/Modern_C++_Design)
    - [`RObject_Impl` class](http://dirk.eddelbuettel.com/code/rcpp/html/RObject_8h.html)
    - [`RObjectMethods` class](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1RObjectMethods.html)
    - [`StoragePolicy` class](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1StoragePolicy.html)
    - [`SlotProxyPolicy` class](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1SlotProxyPolicy.html)
    - [`AttributeProxyPolicy` class](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1AttributeProxyPolicy.html)
    - [`typedef` at cppreference.com](http://en.cppreference.com/w/cpp/language/typedef)

## Member Functions {#member-functions}

### Operators {#ops}

- Operators allow for operations to take place between two different `Vector` or `Matrix` objects. 
  The operations are defined to works in an element-wise fashion where applicable.

- Viable mathematical operations that are able to be performed.

| Operation | Definition         | Vector-Vector | Vector-Scalar  | Vector-Matrix | Matrix - Matrix | Matrix - Scalar |
|:---------:|:------------------:|:-------------:|:--------------:|:-------------:|:---------------:|:---------------:|
|    +      | Addition           |       Yes     |     Yes        |     No        |       No        |       Yes       |
|    -      | Subtraction        |       Yes     |     Yes        |     No        |       No        |       Yes       |
|    /      | Division           |       Yes     |     Yes        |     No        |       No        |       Yes       |
|    *      | Multiplication     |       Yes     |     Yes        |     No        |       No        |       Yes       |


- Logical Operations

| Operation | Definition                | Vector-Vector | Vector-Scalar  |  Vector-Matrix  | Matrix - Matrix | Matrix - Scalar |
|:---------:|:-------------------------:|:-------------:|:--------------:|:---------------:|:---------------:|:---------------:|
|   ==      | Equality                  |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   !=      | Non-equality              |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   >=      | Greater than or equal to  |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   <=      | Less than or equal to     |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   <       | Less than                 |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   >       | Greater than              |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   !       | Negate                    |       Yes     |     Yes        |     No          |       No        |       Yes       |

- Examples:
 
```{Rcpp sugar_math_ops}
// Sample data
NumericVector A = NumericVector::create(1, 2, 3, 4);
NumericVector B = NumericVector::create(2, 3, 4, 5);

// --- Addition

// Add a vector and scalar
NumericVector H = A + 2.0;
// Output: 3 4 5 6

// Add a vector and another vector
NumericVector I = A + B;
// Output: 3 5 7 9

// --- Subtraction

// Subtract a scalar from a vector
NumericVector J = 2.0 - A;
// Output: 1 0 -1 -2

// Subtract vectors
NumericVector K = A - B;
// Output: -1 -1 -1 -1

// --- Multiplication

// Multiple by scalar
NumericVector L = 3 * A;
// Output: 3 6 9 12

// Multiple Vectors
NumericVector M = A * B;
// Output: 2 6 12 20

// --- Division

// Divide by scalar
NumericVector L = 1 / A;
// Output: 1.0000000 0.5000000 0.3333333 0.2500000

// Divide Vectors
NumericVector M = A / B;
// Output: 0.5000000 0.6666667 0.7500000 0.8000000

// --- All together
NumericVector res = 3.0 * A - 1.0 / B + A + B + 5.0;
// Output: 10.50000 15.66667 20.75000 25.80000
```

### Dimensional Information {#diminfo}

|                       |                                              |
|:----------------------|:---------------------------------------------|
| `.nrow()`,`.rows()`   | number of rows in a `Matrix`, `DataFrame`    |
| `.ncol()`,`.cols()`   | number of columns in a `Matrix`, `DataFrame` |
| `.size()`,`.length()` | number of items in a `Matrix`, `Vector`      |

- Return type is that of an `int`, `unsigned int`, or `R_xlen_t`

- Note: As of Rcpp 0.13.0, new size attribute accessors were added to the 
  `DataFrame` class that mimick those available in `Matrix`. Previously, to
   obtain the number of columns, one would have to use the `.size()` or `.length()`
   member function. In addition, the number of observations previously had to
   be obtained by `.nrows()`. 

- Examples:

```{Rcpp dimensional_info}
// --- Vector Example
NumericVector X(3);

int nelem = X.size();   // Output: 3
int nlens = X.length(); // Output: 3

Rcout << "Vector X has " << nelem << " elements." << std::endl;

// --- Matrix Example
NumericMatrix X(4,5);

int rows  = X.nrow();   // Output: 4
int cols  = X.ncols();  // Output: 5
int elems = X.size();   // Output: 20

Rcout << "Matrix Y has " << rows << " rows and " << cols << " columns." << std::endl;
```


### Element Access {#elem-access}

- Described within this section is the ability to access elements using 
  the position, categorical, and logical indexing systems.

- The access system provides two retrieval methods for all classes
  that differ in computational time to obtain values from objects. 
    - The preferred method to access elements is `()`, which that takes slightly
    longer due to a bounds check being performed that verifies whether the 
    requested element is within the access scope. Furthermore, if the 
    requested element is out of bounds, an exception is raised and the program
    stops.
    - The other method uses `[]`, which does _not_ perform a bounds check and
    assumes that the access scope is valid. If an element is out of bounds,
    the behavior exhibited will be undefined and may cause havoc with later
    parts of a procedure. Only use this form of accessor if the procedure has
    been thoroughly tested and debugged.
  
- Note: Using accessors without a bounds check is **not** recommended unless 
  the code has been thoroughly tested as undefined behavior (UB) may emerge. UB 
  is very problematic.
  
#### Position Access {#position-access}

- Access a single element or object using a positional index.
   - `(i)` provides the *i*th element or object in addition to performing a 
   bounds check that ensures the requested index is a valid location.
   - `[i]` similar to the previous case, but does so *without* a bounds check.
   - `at(i,j)` provides the *i,j*th element of a `Matrix` with a bounds check.
   - `(i,j)` provides the *i,j*th element of a `Matrix` *without* a bounds check.

- **Caveat:** Using either `[i]` or `(i)` on `List` and `DataFrame`,
  provides the object (e.g. `Vector`) at position *i* whereas the use on 
  `Vector` or `Matrix` will provide a scalar element (e.g. `double`).
 
- Note: Unlike _R_, there is no `[]` subset operator for matrices with _C++_.
  The reason for the lack of `operator[]` relates to a fundamental design choice 
  made by the creators of C++ related to the presence of the 
  [`operator,`](http://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator).
  In essence, after the complete evaluation of the first coordinate `x` and disposal
  of the results, only then is the second coordinate `y` able to be evaluated.
  Unfortunately, this yields the following `-Wall` issue: 
  
  > left operand of comma operator has no effect.
  
  Therefore, the only viable matrix subset operators within C++ are `operator()` and `operator at()` provide subset operations.
  
- Examples:

```{Rcpp position_access}
// Create data 
NumericVector A = NumericVector::create(1, 2, 3, 4);
CharacterVector C = CharacterVector::create("B", "D", "E", "F");

// --- Vector 

// Retrieve the first value from A. (C++ indices start at 0 not 1!)
double a = A(0);
// Output: 1

// Modify the last value using unbound accessor
// Warning: Make sure the point is valid!
A[3] = 5;

// --- Matrix

// Create matrix with elements in A
NumericMatrix B(2, 2, A.begin());

// Output:
// 1  3
// 2  5

// Extract Value at 2, 1
double val_r1c0 = B(1, 0);
// Output: 2

// Modify value at 1, 2
B(0, 1) = 4;

// Output:
// 1  4
// 2  5

// The following shows a bounds throw error
// B.at(1, 2) = 4;

// --- List

// Create a List
List D = List::create(Named("A") = A,
                          _["C"] = C); // shorthand for Named("C")

// Extract A from List
NumericVector E = D[0];

double val2 = E[1];
// Output: 2

// Extract B from List
CharacterVector F = D[1];

// --- Data Frame

// Create a DataFrame
DataFrame G = DataFrame::create(Named("A") = A,
                                    _["C"] = C); // shorthand for Named("C")

// Extract A from DataFrame
NumericVector E = DF[0];
```

#### Categorical Access {#categorical-access}

- Access element by name within a `Vector`, `List`, or `DataFrame`.
   - `(NAME)` provides the element associated with the `NAME` in addition to 
       performing a bounds check that ensures the requested `NAME` exists.
   - `[NAME]` similar to the previous case, but does so *without* a bounds check. 

- Examples:

```{Rcpp string_access}
// Create sample data
NumericVector A = NumericVector::create(Named("Go") = 3,
                                        Named("To") = 4,
                                            _["My"] = 5, // shorthand Named("My")
                                            _["Pi"] = 1);
// Output: (names only printed in R!) 
// Go To My Pi 
//  3  4  5  1

NumericVector B = NumericVector::create(2, 5, 8, 9, 3, 7);

// Alternative way to set name values
B.names() = CharacterVector::create("Bears","Lions","and","Tigers", "Oh", "My");
// Output: (names only printed in R!) 
// Bears  Lions    and Tigers     Oh     My 
//     2      5      8      9      3      7 

// --- Vector

double val_num = A["To"];
// Output: 
// To
//  4

// Subset by vector
CharacterVector C = CharacterVector::create("My", "Pi");

NumericVector D = A[C];
// Output: (names only printed in R!) 
// My Pi 
//  5  1

// Modify values in vector
NumericVector E = NumericVector::create(1, 2);
A[C] = E;
// Output:
// Go To My Pi 
//  3  4  1  2

// --- List

// Create a List
List F = List::create(Named("A") = A,
                          _["B"] = B); // shorthand for Named("B")

// Extract A from List
NumericVector G = F["A"];

double val_go = G["Go"];
// Output: 3

// --- Data Frame

// Create a DataFrame
DataFrame H = DataFrame::create(Named("A") = A,
                                    _["B"] = B); // shorthand for Named("B")

// Extract B vector from DataFrame
NumericVector I = H["B"];

double val_lions = I["Lions"];
// Output: 5
```

#### Logical Access {#logical-access}

- Access element by boolean values within a `Vector`, `List`, or `DataFrame`.
   - `(BOOL)` provides only the elements associated `true` logical
       condition in addition to performing a bounds check that ensures the 
       requested element at the `BOOL` location exists.
   - `[BOOL]` similar to the previous case, but does so *without* a bounds check. 

- **Caveat:** The `BOOL` must be a `LogicalVector` of equal size to the object
  being subset.

- Examples: 

```{Rcpp logical_access}
// Sample data
NumericVector A = NumericVector::create(4, 3, 1, 2);
// Output: 4 3 1 2

// Logical Subset
LogicalVector B = LogicalVector::create(true, false, false, true);
// Output: TRUE FALSE FALSE TRUE

NumericVector C = A[B];
// Output: 4 2

// Replace Values
NumericVector D = NumericVector::create(8, 6);

// Logical Replacement
A[B] = D;
// Output: 4 8 6 2
```

### Subset Views {#subview}


### Iterators {#iterators}

- C++ Standard Template Library (STL) styled random access iterators exist underlying
  the `Vector` and `Matrix` classes.

- Iterator accessor:

|              |                                     |
|:-------------|:------------------------------------| 
| `·begin()`   | pointer to the start of the vector  |
| `·end()`     | pointer to one past end of vector   |


- Kinds of Iterators:

|                               |                                                             |
|:------------------------------|:------------------------------------------------------------|
| `NumericVector::iterator`     | allows for read/write access to elements (stored by column) |
| `ComplexVector::iterator`     |                                                             |
| `IntegerVector::iterator`     |                                                             |
| `LogicalVector::iterator`     |                                                             |
| `CharacterVector::iterator`   |                                                             |
| `RawVector::iterator`         |                                                             |
| `ExpressionVector::iterator`  |                                                             |
| `GenericVector::iterator`     |                                                             |
| `NumericMatrix::iterator`     |                                                             |
| `ComplexMatrix::iterator`     |                                                             |
| `IntegerMatrix::iterator`     |                                                             |
| `RawMatrix::iterator`         |                                                             |
| `LogicalMatrix::iterator`     |                                                             |
| `CharacterMatrix::iterator`   |                                                             |
| `StringMatrix::iterator`      |                                                             |
| `ExpressionMatrix::iterator`  |                                                             |
| `GenericMatrix::iterator`     |                                                             |
| `ListMatrix::iterator`        |                                                             |


|                                     |                                                       |
|:------------------------------------|:------------------------------------------------------|
| `NumericVector::const_iterator`     | allows for read access to elements (stored by column) |
| `ComplexVector::const_iterator`     |                                                       |
| `IntegerVector::const_iterator`     |                                                       |
| `LogicalVector::const_iterator`     |                                                       |
| `CharacterVector::const_iterator`   |                                                       |
| `RawVector::const_iterator`         |                                                       |
| `ExpressionVector::const_iterator`  |                                                       |
| `GenericVector::const_iterator`     |                                                       |
| `NumericMatrix::const_iterator`     |                                                       |
| `ComplexMatrix::const_iterator`     |                                                       |
| `IntegerMatrix::const_iterator`     |                                                       |
| `RawMatrix::const_iterator`         |                                                       |
| `LogicalMatrix::const_iterator`     |                                                       |
| `CharacterMatrix::const_iterator`   |                                                       |
| `StringMatrix::const_iterator`      |                                                       |
| `ExpressionMatrix::const_iterator`  |                                                       |
| `GenericMatrix::const_iterator`     |                                                       |
| `ListMatrix::const_iterator`        |                                                       |


```{Rcpp}
// Sample Data
NumericVector A = NumericVector::create(-1, 3.2, 0, 14.2, 38.6);
    
// --- Use iterators to compute sum
double val_total = 0;

for(NumericVector::iterator iter = A.begin(); iter != A.end(); ++iter) {
  val_total += *iter;
}

Rcpp::Rcout << "Sum Value is " << val_total << std::endl;
// Output: Sum Value is 55
```

### STL-style container functions {#stl-functions}

- There exists a special class of member functions that mimic how C++ Standard
  Template Library (STL) implement member functions for container architecture
  such as `vector`, `deque`, and `list`. 

- Member functions that do _not_ alter the **size** of the Rcpp object

| Member                 | Description                                 |
|:-----------------------|:--------------------------------------------|
| `operator()`           | Access elements _with_ checking range       |
| `operator[]`           | Access elements _without_ checking range    |
| `.length()`, `.size()` | Amount of elements in the collection        |
| `.fill(u)`             | Fill the collection with element `u`        |

- Member functions that _do_ alter the **size** of the Rcpp object and result
  in the object being recreated.

| Member           | Description                                         |
|:-----------------|:----------------------------------------------------|
| `·push_back(x)`  | Insert `x` at end of vector, grows vector           |
| `·push_front(x)` | Insert `x` at beginning of vector, grows vector     |
| `·insert(i, x)`  | Insert `x` at the _i_^th^ position of, grows vector |
| `·erase(i)`      | Remove element at _i_^th^ position, shrinks vector  |

- **Warning:** Using any function to grow or shrink an Rcpp object results 
  in the data being _copied_ from the original object into a new object. As a 
  result, there will be a severe degregation of performance. Therefore, it is
  highly recommended to convert the Rcpp object to an STL object that can easily
  be grown or shrunk if the sample size is _not_ known in advance.

### Static Member Functions {#static-members}

#### create {#create}

|                         |
|:------------------------|
| **::create(X, Y)**      |
| **::create(X, Y, ...)** |


**::create(X, Y, ...)**

- Initializes a `Vector`, `List`, or `DataFrame` by combining objects together
  sequentially in a manner similar to `c(1, 2)` in *R*.

- In the case of a `Vector`, the values *X* and *Y* must be an atomic value of 
  the same underlying type *T*,  where *T* is one of the following:
    - `int` 
    - `double`
    - `std::complex<double> / Rcomplex` 
    - `bool`

- For either a `DataFrame` or `List`, *X*, *Y* are allowed to be any combination
  of `Vector`, `Matrix`, and the previously mentioned supported atomic types.

- `create` is defined for any number of arguments between 1 and 20, inclusive. 

- When constructing examples, it is often preferable to use `create` method
  to build a vector.

- Examples: 
          
```{Rcpp static_create}
// Construct a vector
NumericVector A = NumericVector::create(4.2, 1.9, 2, 3.5);
// Output: 4.2 1.9 2.0 3.5

IntegerVector B = IntegerVector::create(1, 2);
// Output: 1 2

CharacterVector C = CharacterVector::create("a", "b", "c", "d");
// Output: "a" "b" "c" "d"


// Unnammed list creation
List D = List::create(1.5, 2.3, 4.5);
// Must be returned into R for output!
// Output:
// [[1]]
// [1] 1.5
// [[2]]
// [1] 2.3
// [[3]]
// [1] 4.5

// Named list creation
List E = List::create(Named("B") = B,           
                       _["nval"] = 2.5);         // shorthand for Named("nval")
// Must be returned into R for output!
// $B
// [1] 1 2
// 
// $val
// [1] 2.5

// DataFrame creation
// The number of elements in vectors must _match_
DataFrame F = DataFrame::create(Named("A") = A,  
                                    _["C"] = C); // shorthand for Named("C")
// Must be returned into R for output!
// Output:
//   A C
// 4.2 a
// 1.9 b
// 2.0 c
// 3.5 d
```



#### get_na() {#get_na}

- Obtain the correct missing value constant for the given _RTYPE_ associated
  with the Rcpp data structure.

- Examples: 
          
```{Rcpp static_get_na}
// Construct a vector
NumericVector A = NumericVector::create(NA_REAL, -1, NumericVector::get_na(), 0);
// Output: NA -1 NA 0

A[3] = NumericVector::get_na();
// Output: NA -1 NA NA
```

- See also:
    - [Setting Infinite, Missingness, and NaN Values](#nan-constants)
    - [Sugar: Finite, Infinite, Missingness, and NaN Detection](#sugar-nan)

#### is_na() {#is_na_static}

- Determine whether an element within the Rcpp data structure matches a missing
  constant of the given _RTYPE_.

- Examples: 
          
```{Rcpp}
// Construct a vector
NumericVector A = NumericVector::create(NA_REAL, -1, NumericVector::get_na(), 0);

int n = A.size();
LogicalVector B(n);
  
for (int i = 0; i < n; ++i) {
    B[i] = NumericVector::is_na(A[i]);
}

Rcout << "NA Presence: " << B << std::endl;
// Output: NA Presence: 1 0 1 0
```

- See also:
    - [Setting Infinite, Missingness, and NaN Values](#nan-constants)
    - [Missing Values and NaN Detection](#missingness)

#### import(InputIterator first, InputIterator last) {#import}


#### import_transform(InputIterator first, InputIterator last, F f) {#import-transform}


#### diag(int size, const U &diag_value) {#diag-static}

- This method is available only for the `Matrix` class.

- Examples:

```{Rcpp diag_static}

```

#### eye(int n) {#eye}

- This method is available only for the `Matrix` class.

- Examples:

```{Rcpp eye_static}

```

#### ones(int n) {#ones}

- This method is available only for the `Matrix` class.

- Examples:

```{Rcpp ones_static}

```

#### zeros(int n) {#zeros}

- This method is available only for the `Matrix` class.

- Examples:

```{Rcpp zeros_static}

```

## Environment


## Function

## Language

## XPtr

## S4 Classes

## Sugar {#sugar}

- The objective behind _Rcpp sugar_ is to provide a subset of the
  high-level _R_ syntax in _C++_. For instance, part of the functionality 
  behind the [`table( X )`](#table) function can be 

- Unless otherwise noted, if a `Matrix` is supplied, then the `Matrix` is 
  corcered into column-form vectors before having the sugar functional procedure
  performed. For example, given a 2x2 matrix the results of the function call
  will go R1C1, R2C1, R1C2, and R2C2 where _R_ stands for Row and
  _C_ for column.

### Logical Operations {#sugar-logic-ops}

- Boolean functions that provide a way to analyze the data are provided within.

#### ifelse( CONDITION, TRUEVAL, FALSEVAL) {#if-else}

- Vectorized `if-else` assignment of elements dependent on the `CONDITION`
  being `true` (`TRUEVAL`) or `false` (`FALSEVAL`). 

- To use the vectorized `if-else` the following criteria must be met:
    - `CONDITION`: A `LogicalVector` or a sugar expression that evalutes to a `LogicalVector`
    - `TRUE`/`FALSE`: either
        1. two compatible sugar expression (same *RTYPE*, same length), OR
        2. one sugar expression and one compatible primitive (same *RTYPE*)

- **Caveat:** Unlike the _R_ equivalent, there is no recycling the occurs if
  the vectors are of different lengths. In said cases, an error will be raised
  at runtime indicating the length difference.

```{Rcpp vectorized_ifelse}
// Create data
NumericVector A = NumericVector::create(5, 1, 8, 3);
NumericVector B = NumericVector::create(2, 4, 6, 11);

// a.) Vectors of the same length and type
NumericVector C = ifelse(A < B, A, (A + B)*B);
// Output: 14 1 84 3

// b.) One vector and one constant
NumericVector D = ifelse(A > B, A, 2);
// Output: 5 2 8 2
```

#### Single Logical Result {#single-logical}

|                   |                   |
|:------------------|:------------------|
| **is_true( X )**  | **is_false( X )** |

- Convert the result state of `any( CONDITION )` and `all( CONDITION )` from the
  `SingleLogicalResult` template class to an atomic value `bool` evaluated
  as either `true` or `false` dependent on whether the call to `is_true( X )` or
  `is_false( X )` is matched. 
  
- For example, if `any( CONDITION )` evaluates to `false` than `is_true( X )` 
  will return `false` but `is_false( X )` will return `true`.

- Examples:

```{Rcpp single_logical}
IntegerVector A = seq_len(3);
// Output: 1 2 3
IntegerVector B = clone(A) - 1;
// Output: 0 1 2

bool check_state_true  = is_true( any(A > B) );
// Output: true

bool check_state_false = is_false( any(A > B) );
// Output: false

// Without using the above functions, a compile time error will trigger
// on assignment to bool.
// bool check_state_error = any( A > B );
// Error: invalid use of incomplete type 'class Rcpp::sugar::forbidden_conversion<false>'
// class conversion_to_bool_is_forbidden
```

- See also:
    - [any](#any)
    - [all](#all)

#### all( X ) {#all}

- Tests if *all* elements in a `LogicalVector` or `LogicalMatrix` are `true`. 

- The actual return type of `all(X)` is an instance of the 
  `SingleLogicalResult` template class, but the functions `is_true` 
  and `is_false` may be used to convert the return value to `bool`.
  
- Examples: 

```{Rcpp logical_all}
NumericVector A = NumericVector::create(1.0, 2.0, 3.0, 4.0);

Rcout
    << std::boolalpha
    << "all(A < 5): " << is_true(all(A < 5)) << "\n"
    << "all(A < 4): " << is_true(all(A < 4)) << "\n"
    << "all(!is_na(A)): " << is_true(all(!is_na(A))) 
    << "\n\n";
// Output:
// all(A < 5): true
// all(A < 4): false
// all(!is_na(A)): true

NumericMatrix B(2, 2, A.begin());

Rcout
    << std::boolalpha
    << "all(B < 5): " << is_true(all(B < 5)) << "\n"
    << "all(B < 4): " << is_true(all(B < 4)) << "\n"
    << "all(!is_na(B)): " << is_true(all(!is_na(B))) 
    << "\n\n";
// Output:
// all(B < 5): true
// all(B < 4): false
// all(!is_na(B)): true

Rcout
    << std::boolalpha
    << "all({true, true, true}): "
    << is_true(all(LogicalVector::create(true, true, true))) << "\n"
    << "all({true, true, false}): "
    << is_true(all(LogicalVector::create(true, true, false))) 
    << std::endl;
// Output: 
// all({true, true, true}): true
// all({true, true, false}): false
```

- See also:
    - [any](#any)
    - [is_true](#single-logical)
    - [is_false](#single-logical)
    - [is_na](#is-na)

#### any( X ) {#any}

- Tests if *any* elements in a `LogicalVector` or `LogicalMatrix` are `true`. 

- The actual return type of `any(X)` is an instance of the 
  `SingleLogicalResult` template class, but the functions `is_true` 
  and `is_false` may be used to convert the return value to `bool`.
  
- Examples: 

```{Rcpp logical_any}
NumericVector A = NumericVector::create(1.0, 2.0, 3.0, 4.0);

Rcout
    << std::boolalpha
    << "any(A > 3): " << is_true(any(A > 3)) << "\n"
    << "any(A > 4): " << is_true(any(A > 4)) << "\n"
    << "any(is_na(A)): " << is_true(any(is_na(A))) 
    << "\n\n";
// Output:    
// any(x > 3): true
// any(x > 4): false
// any(is_na(x)): false

NumericMatrix B(2, 2, A.begin());
B[0] = NumericMatrix::get_na();

Rcout
    << std::boolalpha
    << "any(B > 3): " << is_true(any(B > 3)) << "\n"
    << "any(B > 4): " << is_true(any(B > 4)) << "\n"
    << "any(is_na(B)): " << is_true(any(is_na(B))) 
    << "\n\n";
// Output:    
// any(B > 3): true
// any(B > 4): false
// any(is_na(B)): true

Rcout
    << std::boolalpha
    << "any({false, false, false}): "
    << is_true(any(LogicalVector::create(false, false, false))) << "\n"
    << "any({true, false, false}): "
    << is_true(any(LogicalVector::create(true, false, false))) 
    << std::endl;
// Output:
// any({false, false, false}): false
// any({true, false, false}): true
```

- See also:
    - [all](#all)
    - [is_true](#single-logical)
    - [is_false](#single-logical)
    - [is_na](#is-na)

### Complex Operators {#sugar-complex-ops}

#### Complex Components {#complex-number}

|             |             |
|:------------|:------------|
| **Re( X )** | **Im( X )** |

- Extract the real or imaginary component of a complex number.

- Definition: $$z = x + i y$$, where $x, y \in \mathbb{R}$.

- *X* must be stored within a `Vector` or `Matrix` of type `Complex`. The 
  return type is a `NumericVector` regardless of whether a `Vector` or `Matrix`
  is supplied. 

- Example:

```{Rcpp complex_components}
// Create complex numbers
Rcomplex x, y;

// Assign real, imaginary values
x.r = 5.0; x.i = 12.0;
y.r = 9.2; y.i = -4.0;

// Make a complex vector
ComplexVector A = ComplexVector::create(x, y);
// Output: 5+12i 9.2+-4i

NumericVector B = Re(A);
// Output: 5 9.2

NumericVector C = Im(A);
// Output: 12 -4
```


- See also:
    - [Conj](#complex-conjugate)

#### Mod( X ) {#complex-modulus}

- Compute the modulus of a complex number or the length from the origin to the
  point represented in the complex plane (radius in polar coordinates).
  
- Definition: $$r = \operatorname{Mod}(z) = \sqrt{x^2 + y^2}$$

- *X* must be stored within a `Vector` or `Matrix` of type `Complex`. The 
  return type is a `NumericVector` regardless of whether a `Vector` or `Matrix`
  is supplied. 

- Example:

```{Rcpp complex_modulus}
// Create complex numbers
Rcomplex x, y;

// Assign real, imaginary values
x.r = 5.0; x.i = 12.0;
y.r = 9.2; y.i = -4.0;

// Make a complex vector
ComplexVector A = ComplexVector::create(x, y);
// Output: 5+12i 9.2+-4i

NumericVector B = Mod(A);
// Output: 13.00000 10.031949
```

- See also:
    - [Arg](#complex-arg)

#### Arg( X ) {#complex-arg}

- Compute the argument of a complex number or the angle from the positive side
  of the real axis to the line segment connecting the origin and the point in 
  the complex plane (theta in polar coordinates).

- Definition: $$\theta = \arctan\left({\frac{y}{x} }\right)$$

- *X* must be stored within a `Vector` or `Matrix` of type `Complex`. The 
  return type is a `NumericVector` regardless of whether a `Vector` or `Matrix`
  is supplied. 

- Example:

```{Rcpp complex_arg}
// Create complex numbers
Rcomplex x, y;

// Assign real, imaginary values
x.r = 5.0; x.i = 12.0;
y.r = 9.2; y.i = -4.0;

// Make a complex vector
ComplexVector A = ComplexVector::create(x, y);
// Output: 5+12i 9.2+-4i

NumericVector B = Arg(A);
// Output: 1.1760052 -0.4101273
```

- See also:
    - [Mod](#complex-modulus)

#### Conj( X ) {#complex-conjugate}

- Compute the complex conjugate of a complex number or a number with an equivalent
  real component by negated imaginary component.

- *X* must be stored within a `Vector` or `Matrix` of type `Complex`. The 
  return type is a `ComplexVector` regardless of whether a `Vector` or `Matrix`
  is supplied. 

- Example:

```{Rcpp complex_conjugate}
// Create complex numbers
Rcomplex x, y;

// Assign real, imaginary values
x.r = 5.0; x.i = 12.0;
y.r = 9.2; y.i = -4.0;

// Make a complex vector
ComplexVector A = ComplexVector::create(x, y);
// Output: 5+12i 9.2+-4i

ComplexVector B = Conj(A);
// Output: 5-12i 9.2+ 4i
```

- See also:
    - [Re](#complex-number)
    - [Im](#complex-number)


### Data Operations {#sugar-data}


#### First or Last Elements {#first-last-elems}

|                   |                   |
|:------------------|:------------------|
| **head( X , n )** | **tail( X , n )** |

- Obtain the first or last _n_ observations using `head` or `tail`.

- All types of a `Vector` or `Matrix` are supported.

- Example:

```{Rcpp pop_elements}
NumericVector A = NumericVector::create(1, 3, 5, 7, 9, 11);

// Retrieve the first two elements
NumericVector B = head(A, 2);
// Output: 1 3

// Retrieve the last two elements
NumericVector C = tail(A, 2);
// Output: 9 11
```

----

#### abs( X ) {#abs}

- Obtain the absolute value of all elements.

- Definition: \[ \left| X \right| = \begin{cases}
X,  &\text{if} X \ge 0 \\
-X, &\text{if} X < 0
\end{cases}\]

- Supported types to perform the operation are `Numeric` or `Integer`
  of a `Vector` or `Matrix`. 

- Example:

```{Rcpp absolute_val}
// Sample data
NumericVector A = NumericVector::create(-2.8, 5.3, 7, -4, 0);

NumericVector B = abs(A);
// Output: 2.8, 5.3, 7, 4, 0
```

----

#### sqrt( X ) {#sqrt}

- Compute the square root of all elements.

- Definition: \[ \sqrt{X} = X^{1/2}\]

- Supported types to perform the operation are `Numeric`, `Integer`, or `Complex`
  of a `Vector` or `Matrix`. 

- Example:

```{Rcpp sqrt_val}
// Sample data
NumericVector A = NumericVector::create(0.0, 1.0, 2.5, 5.0, 9.0);

NumericVector B = sqrt(A);
// Output: 0 1 1.58114 2.23607 3
```

----

#### pow( X , n) {#pow}

- Obtain the power of the _i_^th^ element raised to the _n_ power.

- Definition: \[ Y = X^{n}\]

- Supported types to perform the operation are `Numeric` or `Integer`
  of a `Vector` or `Matrix`. 

- **Caveat:** Only _X_ is able to be vectorized. The value of _n_ must be
  a scalar of `int` or `double` type.

- Example:

```{Rcpp pow_val}
// Sample data
NumericVector A = NumericVector::create(0.0, 1.0, 2.5, 5.0, 9.0);

NumericVector B = pow( A , 3 );
// Output: 0 1 15.625 125 729
```

----

#### sum( X ) {#sum}

- Calculate the overall summation of all elements. 

- Definition: $$Y = \sum\limits_{i = 1}^n { {X_i} } $$

- Supported types to perform the operation are `Numeric` or `Integer`
  of a `Vector` or `Matrix`. 

- Example:

```{Rcpp sum_val}
// Sample data
NumericVector A = NumericVector::create(3.2, 8.1, 9.5, 8.6, 5.7);

double val_summed = sum(A);
// Output: 35.1
```

- See also:
    - [`rowSums` / `colSums`](#matrix-sum)

----

#### sign( X ) {#sign}

- Determine the sign of a number or whether a number is positive, negative, or
  zero.
  
- Definition: \[\operatorname{sgn} \left( X \right) = \begin{cases}
-1, &\text{if} x < 0 \\
0, &\text{if} x = 0 \\
1, &\text{if} x > 0 
\end{cases}\]

- Supported types are `Numeric` or `Integer` of a `Vector` or `Matrix`.

- Example:

```{Rcpp sign_val}
// Create some sample data
NumericVector A = NumericVector::create(-1, 0, 1, -3.4, 42);

// --- Obtain values of the sign

NumericVector B = sign(A);
// Output: -1  0  1 -1  1
```

----

#### diff( X ) {#diff}

- Obtain the difference between sucessive `Vector` elements by 
  $(i+1)$^th^ and the _i_-^th^ element.
  
- Definition: $$ \nabla {X_i} = {X_{i + 1} } - {X_i} $$
  
- Supported types are `Numeric` or `Integer` of a `Vector` or `Matrix`.

- Example:

```{Rcpp diff_val}
// Create some sample data
NumericVector A = NumericVector::create(-2, 0, 0.5, -1, 2.5, 4.75);

// --- Obtain difference

NumericVector B = diff(A);
// Output: 2.00  0.50 -1.50  3.50  2.25
```

----

#### Cumulative Arithmetic {#carth}

|                 |                  |
|:----------------|:-----------------|
| **cumsum( X )** | **cumprod( X )** |

- Calculates the cumulative sum (`cumsum`) or cumulative product (`cumprod`) 
  of a `Vector` or `Matrix` *X*. 
  
- If an `NA` value is encountered, it will be propagated throughout the 
  remaining elements in the result vector. 

- For `cumsum`, *X* should be an `Integer` or `Numeric` `Vector` or `Matrix`. 

- For `cumprod`, *X* should be an `Integer`, `Numeric`, or `Complex` `Vector` 
  or `Matrix`. 
  
- In either case, the return type is a `Vector` of the same underlying `SEXPTYPE` 
  as the input. 
  
- Caveat: at the time of writing (Rcpp version 0.12.8.2), not all Sugar expressions 
  are directly compatible with `Vector::operator=`, as many of these functions 
  return intermediate template classes which require an explicit conversion to   
  `Vector`, rather than directly returning a `Vector`. In such cases the user 
  may need to "help" the compiler with the conversion by 
  
    - Constructing a `Vector` from the result, and assigning that to the 
      target `Vector`; or
    - Calling an explicit conversion member function of the Sugar class, if 
      such a function exists.
      
    See the examples below for a demonstration. 
  
- Examples: 

```{Rcpp cumarith}
NumericVector x = NumericVector::create(1, 2, 3, 4, 5);
NumericVector cs = cumsum(x), cp = cumprod(x);

Rcout
    << "cumsum(x): \n" << cs << "\n\n"
    << "cumprod(x): \n" << cp << "\n\n";
// Output:
// cumsum(x): 
// 1 3 6 10 15
// 
// cumprod(x): 
// 1 2 6 24 120

x[3] = NumericVector::get_na();

cs = cumsum(x).get();
cp = cumprod(x).get();

// These print as `nan`, but are actually `NA` values
Rcout
    << "cumsum(x): \n" << cs << "\n\n"
    << "cumprod(x): \n" << cp 
    << std::endl;
// Output: 
// cumsum(x): 
// 1 3 6 nan nan
// 
// cumprod(x): 
// 1 2 6 nan nan

// As noted above: 
NumericVector y = NumericVector::create(1, 2, 3, 4, 5);

NumericVector cs = cumsum(y);   // OK, calls copy *constructor*, not 
                                // copy assignment operator

// cs = cumsum(y);      compiler error: no viable conversion from 
//                      'const Rcpp::sugar::Cumsum<14, true, Rcpp::Vector<14, PreserveStorage> >' 
//                      to 'SEXP' (aka 'SEXPREC *')

cs = cumsum(y).get();           // OK, `get()` returns a VectorBase, which is 
                                // assignable to Vector
                                
cs = NumericVector(cumsum(y));  // OK, but requires an additional Vector 
                                // to be created
```

----

#### Cumulative Extremum {#cext}

|                 |                  |
|:----------------|:-----------------|
| **cummax( X )** | **cummin( X )**  |


----


#### trigonometric element-wise functions {#trig}

|              |                |               |
|:-------------|:---------------|:--------------|
| **sin( X )** | **asin( X )**  | **sinh( X )** |
| **cos( X )** |  **acos( X )** | **cosh( X )** |
| **tan( X )** |  **atan( X )** | **tanh( X )** |

- Compute the trigonometric value for each element in a given structure.

- Usage:
   - `vector_type Y = func(X)`
   - `X` and `Y` must be of the same `vector_type`/`matrix_type`.
   - where `func` is one of the following trigonmetric functions:
       - sin family: `sin(X)`, `asin(X)`, `sinh(X)`
       - cos family: `cos(X)`, `acos(X)`, `cosh(X)`
       - tan family: `tan(X)`, `atan(X)`, `tanh(X)`

- Supported types are `Integer`, `Numeric`, or `Complex` of a `Vector` or `Matrix`. 

- Examples:

```{Rcpp rcpp_trig_funcs}
// Generate Values
NumericVector X  = rnorm(10);

// Compute trigonometric values
NumericVector Y  =  cos(X);
NumericVector Y2 = acos(X);
NumericVector Y3 = cosh(X);
```

---

#### Logarithms and Exponentials {#logexp}

|              |                |                |
|:-------------|:---------------|:---------------|
| **log( X )** | **log10( X )** | **log1p( X )** | 
| **exp( X )** | **expm1( X )** |                |

- Apply a function to each element

- Usage:
   - `vector_type Y = func(X)`
   - `X` and `Y` must be of the same `vector_type`/`matrix_type`.

- Traditional use case:
   - `log( X )` computes the natural logarithm sometimes representated as $\ln(X)$
   - `log10( X )` computes the base 10 logarithm.
   - `exp( X )` computes the exponential function given by: \[\exp \left( X \right) = \mathop {\lim }\limits_{n \to \infty } {\left( {1 + \frac{X}{n} } \right)^n} = \sum\limits_{k = 0}^\infty  {\frac{ { {X^k} } }{ {k!} } } \]

- Special use cases:
   - `log1p( X )` computes $\log( 1 + X )$ accurately for $\left|X\right| << 1$.
   - `expm1( X )` computes $\exp( X ) - 1$ accurately for $\left|X\right| << 1$.

- Examples:

```{Rcpp rcpp_logs_and_exp}
// Create some sample data
NumericVector A = NumericVector::create(-1, 0, 1, 2.3);

// --- Log and Exp Functions

// Obtain the exponential

NumericVector B = exp(A);
// Output: 0.3678794 1.0000000 2.7182818 9.9741825

// Obtain the natural log, which should recover the initial values

NumericVector C = log(B);
// Output: -1.0  0.0  1.0  2.3

// --- Compare implementations of log1p and expm1 vs. generic

// Create input vector
NumericVector D = no_init(10);

// Fill the vector
for(int i = 0; i < D.length(); ++i){
    D[i] = std::pow(10.0, -1.0*( 1.0 + 2.0*(i+1.0) ) );
}

// Compute values according to definition
NumericVector E = log(1 + D), F = log1p(D), G = exp(D)-1, H = expm1(D);

// Bound values together
NumericMatrix I = cbind(D, E, F, G, H);

// Label columns
colnames(I) = CharacterVector::create("X", "log(1+X)","log1p(X)", "exp(X)+1", "expm1(X)");

// Output:
//           X     log(1+X)     log1p(X)     exp(X)+1     expm1(X)
//  [1,] 1e-03 9.995003e-04 9.995003e-04 1.000500e-03 1.000500e-03
//  [2,] 1e-05 9.999950e-06 9.999950e-06 1.000005e-05 1.000005e-05
//  [3,] 1e-07 1.000000e-07 1.000000e-07 1.000000e-07 1.000000e-07
//  [4,] 1e-09 1.000000e-09 1.000000e-09 1.000000e-09 1.000000e-09
//  [5,] 1e-11 1.000000e-11 1.000000e-11 1.000000e-11 1.000000e-11
//  [6,] 1e-13 9.992007e-14 1.000000e-13 9.992007e-14 1.000000e-13
//  [7,] 1e-15 1.110223e-15 1.000000e-15 1.110223e-15 1.000000e-15
//  [8,] 1e-17 0.000000e+00 1.000000e-17 0.000000e+00 1.000000e-17
//  [9,] 1e-19 0.000000e+00 1.000000e-19 0.000000e+00 1.000000e-19
// [10,] 1e-21 0.000000e+00 1.000000e-21 0.000000e+00 1.000000e-21
```

---

### Rounding of Numbers {#sugar-rounding}


#### Ceiling {#ceil}

|                        |                         |
|:-----------------------|:------------------------|
| **ceiling( X )**       | **ceil( X )**           | 

- Compute the smallest integer value not less than the corresponding element of X.

- Definition: \[\left\lceil X \right\rceil  = \min \left[ {n \in \mathbb{Z}|n \ge X} \right]\]

- Supported types are `Numeric` or `Integer` of a `Vector` or `Matrix`.

- **Note:** `ceil` is a mapping to `ceiling`.

- Examples:

```{Rcpp ceil_val}
// Create some sample data
NumericVector A = NumericVector::create(-3.5, 2, 2.2, 0.1, -.4, -1, 4.75);

// --- Obtain the ceiling

NumericVector B = ceiling(A);
// Output: -3  2  3  1  0 -1  5

// Same result 
NumericVector C = ceil(A);
// Output: -3  2  3  1  0 -1  5
```

----

#### floor( X ) {#floor}

- Compute the largest integer value not greater than the corresponding element of X.

- Definition: \[\left\lfloor X \right\rfloor  = \max \left[ {n \in \mathbb{Z}|n \le X} \right]\]

- Supported types are `Numeric` or `Integer` of a `Vector` or `Matrix`.

- Examples:

```{Rcpp floor_val}
// Create some sample data
NumericVector A = NumericVector::create(-3.5, 2, 2.2, 0.1, -.4, -1, 4.75);

// --- Obtain the floor

NumericVector B = floor(A);
// Output: -4  2  2  0 -1 -1  4
```

----

#### trunc( X ) {#trunc}

- Obtain the integers formed by truncating the values in X toward 0.

- Definition: \[\operatorname{trunc}\left( X \right) = \begin{cases}
               \left\lfloor X \right\rfloor, &\text{if} X > 0 \\
               \left\lceil X \right\rceil, &\text{if} X < 0
               \end{cases}
               \]
               
- Supported types are `Numeric` or `Integer` of a `Vector` or `Matrix`.

- Examples:

```{Rcpp trunc_val}
// Create some sample data
NumericVector A = NumericVector::create(-3.5, 2, 2.2, 0.1, -.4, -1, 4.75);

// --- Obtain the truncated value

NumericVector B = trunc(A);
// Output: -3  2  2  0  0 -1  4
```

- See also:
   - [`ceil`](#ceil)
   - [`floor`](#floor)
   - [Truncation](https://en.wikipedia.org/wiki/Truncation)

----

#### round( X , digits ) {#round}

- Obtain a rounded number to specified number of decimal places.

- There is _no_ default value for `digits`. This parameter _must_ be specified
  with an `int`.

- Supported types are `Numeric` or `Integer` of a `Vector` or `Matrix`.

- Examples:

```{Rcpp round_val}
// Create some sample data
NumericVector A = NumericVector::create(-3.5, 2, 2.2, 0.1, -.4, -1, 4.75);

// --- Obtain the round values

// Default rounds to no decimal places
NumericVector B = round(A, 0);
// Output: -4  2  2  0  0 -1  5

NumericVector C = round(A, 1);
// Output: -3.5  2.0  2.2  0.1 -0.4 -1.0  4.8
```

----

#### signif( X, digits ) {#signif}

- Round the number to the appropriate number of significant digits.

- There is _no_ default value for `digits`. This parameter _must_ be specified
  with an `int`.
  
- Supported types are `Numeric` or `Integer` of a `Vector` or `Matrix`.

- Examples:

```{Rcpp signif_val}
// Create some sample data
NumericVector A = NumericVector::create(11252, 59622, 764, 94512, 4121.5);

// --- Obtain the significant digits

// Default rounds to no decimal places
NumericVector B = signif(A, 2);
// Output: 11000 60000   760 95000  4100

NumericVector C = round(A, 3);
// Output: 11300 59600   764 94500  4120
```

---

### Finite, Infinite, Missingness, and NaN Detection {#sugar-nan}

- Finite numerical representations take the form of base 10 numbers like 1, 2,
  ..., 42, and so on. These values are able to be operated upon such that
  a collection of numerical values can provide a statistical summary.
  However, when working with values that hold special meanings the representation,
  is not necessarily ideal. Therefore, a set of tools exists to detect when 
  values with special meanings exist.

- From [Kevin Ushey's post on StackOverflow](http://stackoverflow.com/questions/26241085/rcpp-function-check-if-missing-value/26262984#26262984),
  we have a set of truth tables or an indicator of whether the value is detected
  by a given function, which covers the R interpreter, Rcpp, and R/C API. Note,
  Rcpp by default follows how R interpreter has crafted the methods.

- R interpreter:

| Function   | `NaN` | `NA` |
|:-----------|:-----:|:----:|
| `is.na`    |  `T`  | `T`  |
| `is.nan`   |  `T`  | `F`  |

- Rcpp:

| Function       | `NaN` | `NA` |
|:---------------|:-----:|:----:|
| `Rcpp::is_na`  |  `T`  | `T`  |
| `Rcpp::is_nan` |  `T`  | `F`  |

- R/C API:

| Function   | `NaN` | `NA`|
|:-----------|:-----:|:---:|
| `ISNAN`    |  `T`  | `T` |
| `R_IsNaN`  |  `T`  | `F` |
| `ISNA`     |  `F`  | `T` |
| `R_IsNA`   |  `F`  | `T` |

- Note: The R/C API is highly inconsistent when detecting values.

#### Setting Infinite, Missingness, and NaN Values {#nan-constants}

- To indicate missingness or `NA` values, the following pre-defined constants 
  have been made available for specific Rcpp data types:

|     Rcpp Data Type       |     Rcpp Value    | Description              |
|:------------------------:|:-----------------:|:------------------------:|
| Numeric<Vector/Matrix>   | `NA_REAL`         | Numeric Missing Value    |
| Integer<Vector/Matrix>   | `NA_INTEGER`      | Integer Missing Value    |
| Logical<Vector/Matrix>   | `NA_LOGICAL`      | Logical Missing Value    |
| Character<Vector/Matrix> | `NA_STRING`       | String Missing Value     |


- To set a missing value type for any type of `Vector` or `Matrix` regardless of
  whether a pre-defined exists, one can use the static member `::get_na()`, e.g.
  `ComplexVector::get_na()` creates an `NA` value for a complex vector.

- The `Numeric` and `double` data types also support the following special 
  constant values:

|     Rcpp Value  |   Value    | Description        |
|:---------------:|:----------:|:------------------:|
|    `R_PosInf`   | `Inf`      | Positive Infinity  |
|    `R_NegInf`   | `-Inf`     | Negative Infinity  |
|    `R_NaN`      | `NaN`      | Not a Number       |

- Note: Understanding the breakdown of the values is important as it relates to 
  detecting whether an element is [finite](#finite), 
  [missing or computationally problematic](#missingness).

- Examples 

```{Rcpp sample_nas}
// Create an NA value for each type
NumericVector A   = NumericVector::create(NA_REAL);
IntegerVector B   = IntegerVector::create(NA_INTEGER);
LogicalVector C   = LogicalVector::create(NA_LOGICAL);
CharacterVector D = CharacterVector::create(NA_STRING);
// Output: NA

// Group all of the above together
List E = List::create(A, B, C, D);
```

- See also:
    - [R Extensions: Missing and IEEE values](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Missing-and-IEEE-values)
    - [R Extensions: Missing and special values](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Missing-and-special-values)

---

#### Finiteness {#finite} 

|                    |                      |
|:-------------------|:---------------------|
| **is_finite( X )** | **is_infinite( X )** |

- Determines whether each element of _X_ are finite (`is_finite`) or infinite (`is_infinite`).

- Support exisits for only the `Numeric` type of a `Vector` or `Matrix`.

- **Note:** Infinite detection is only applicable to `Numeric` types as these 
   values are only defined for `double` types.
   
- **Caveat:** Not a Number is _not_ considered to be a finite nor infinite
   value. If this value exists within the object, it must be detected with 
   `is_nan` or `is_na`.
   
- Examples:

```{Rcpp is_infinite_v_finite}
NumericVector A = NumericVector::create(R_NegInf, -5, 0, 12, R_PosInf, 42,  R_NaN) ;

LogicalVector B = is_finite( A );
// Output: FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE

LogicalVector C = is_infinite( A );
// Output: TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE
```

- See also:
    - [`is_na` / `is_nan`](#missingness)

---

#### Missing Values and NaN Detection {#missingness}

|                    |                      |
|:-------------------|:---------------------|
|    **is_na( X )**  |    **is_nan( X )**   |


- Determines the missing values (`is_na`) or not a number (`is_nan`).

- All types are supported of a `Vector` or `Matrix`.

- Note: The difference between the two functions is explained by in the truth
  table
  

| Function       | `NaN` | `NA` |
|:---------------|:-----:|:----:|
| `Rcpp::is_na`  |  `T`  | `T`  |
| `Rcpp::is_nan` |  `T`  | `F`  |


- Examples:

```{Rcpp is_na_v_nan}
NumericVector X = NumericVector::create(R_NaN, 1, NA_REAL, 3 ) ;

LogicalVector result_na = is_na( X );
// Output: TRUE, FALSE, TRUE, FALSE

LogicalVector result_nan = is_nan( X );
// Output: TRUE, FALSE, FALSE, FALSE
```

---

### na_omit( X ) {#na-omit}

- Removes values that are either `NA` or `NaN`.

- All types are supported of a `Vector` or `Matrix`.

- Example:

```{Rcpp na_omit}
// Create some sample data
NumericVector A = NumericVector::create(R_NaN, 1, NA_REAL, 3 , NA_REAL) ;

// Remove NA and NaN Values
NumericVector B = na_omit(A);
// Output: 1 3
```
  
---

### noNA( X ) {#nona}

- Assert the object is `NA`-free to avoid checking whether each value is not
  missing.

- All types are supported of a `Vector` or `Matrix`.

- **Warning:** Using `noNA` with a `Matrix` defaults the underlying class 
  from a `Matrix` to `VectorBase`! Thus, the matrix dimensional information is 
  _lost_.

- Example:

```{Rcpp noNA}
// Create some sample data
NumericVector A = NumericVector::create(1, 2, 3, 4) ;

// Assert vector is NA-free
NumericVector B = noNA(A);
// Output: 1 2 3 4
```
  
- See also:
   - [StackOverflow: Nathan Russell's Remarks on `noNA`](http://stackoverflow.com/a/41874411/1345455)

---

### The Apply Family {#sugar-apply}


#### sapply {#sapply}

- Apply a _C++_ function or functor to each element of an object and receive
  a `Vector` back.

- The return type is automatically detected by the supplied _C++_
  function or functor of the `Vector` class.

- All types are supported of a `Vector` or `Matrix`.

```{Rcpp sapply_example}

// --- C++ Function Approach
template <typename T>
T square( const T& x){
    return x * x ;
}

IntegerVector test_sapply_function() {
  // Create sample data
  IntegerVector A = seq_len(10);

  // Call C++ Function
  IntegerVector B = sapply(A, square<int>);

  return B;
}

test_sapply_function();
// Output: 1   4   9  16  25  36  49  64  81 100


// --- C++ Functor Approach
template <typename T>
struct square : std::unary_function<T,T> {
  T operator()(const T& x) const { return x * x; }
};
// std::unary_function is deprecated in C++11

IntegerVector test_sapply_functor() {
  // Create sample data
  IntegerVector A = seq_len(10);

  // Call C++ Function
  IntegerVector C = sapply(A, square<int>());

  return C;
}

test_sapply_functor();
// Output: 1   4   9  16  25  36  49  64  81 100
```
---

#### lapply {#lapply}

- Apply a _C++_ function or functor to each element of an object and receive
  a `List` back. 

- All types are supported of a `Vector` or `Matrix`.

```{Rcpp lapply_example}
// --- C++ Function Approach
template <typename T>
T square( const T& x){
    return x * x ;
}

List test_lapply_function() {
  // Create sample data
  IntegerVector A = seq_len(3);

  // Call C++ Function
  List B = sapply(A, square<int>);

  return B;
}

test_lapply_function();
// Output:
// [[1]]
// [1] 1
// [[2]]
// [1] 4
// [[3]]
// [1] 9

// --- C++ Functor Approach
template <typename T>
struct square : std::unary_function<T,T> {
  T operator()(const T& x) const { return x * x; }
};
// std::unary_function is deprecated in C++11

IntegerVector test_lapply_functor() {
  // Create sample data
  IntegerVector A = seq_len(3);

  // Call C++ Function
  List C = lapply(A, square<int>());

  return C;
}

test_lapply_functor();
// Output: 
// [[1]]
// [1] 1
// [[2]]
// [1] 4
// [[3]]
// [1] 9
```

---

#### mapply {#mapply}

- Apply a _C++_ function or functor on up to three input objects and receive
  a `Vector`.

- The return type is automatically detected by the supplied _C++_
  function or functor of the `Vector` class.
  
- All types are supported of a `Vector` or `Matrix`.

- Example:

```{Rcpp mapply_example}
// --- C++ Function Example
template <typename T>
T sum_val(T x, T y, T z) {
     return x + y + z ;
}

// Sample Data
NumericVector A = NumericVector::create(1, 2, 3);
NumericVector B = NumericVector::create(2, 3, 4);
NumericVector C = NumericVector::create(3, 4, 5);

NumericVector D = mapply(A, B, C, sum_val<double>);
// Output: 6 9 12
```

- See also:
   - [`sapply`](#sapply)
   
---

### Special Functions of Mathematics {#sugar-special-math}

#### Beta {#beta}

|                  |                   |
|:-----------------|:------------------|
| **beta( A, B )** | **lbeta( A, B )** |


- Compute value of the beta function, $B \left(a,b\right)$, and the natural 
  logarithm of the beta function,
  $\log \left( {B \left(a,b\right)} \right)$.

- **Definition:**

$$\begin{aligned}
B\left( {a,b} \right) &= \frac{ {\Gamma \left( a \right)\Gamma \left( b \right)} }{ {\Gamma \left( {a + b} \right)} } \\
& = \int\limits_0^1 { {t^{\left( {a - 1} \right)} }{ {\left( {1 - t} \right)}^{\left( {b - 1} \right)} }dt} \\
\log \left( { B\left( {a,b} \right) } \right) &=  \log \left( { \int\limits_0^1 { {t^{\left( {a - 1} \right)} }{ {\left( {1 - t} \right)}^{\left( {b - 1} \right)} }dt} } \right)
\end{aligned}$$

- Supported types are `Integer` or `Numeric` of a `Vector` or `Matrix`. 

- Examples:

```{Rcpp}
// Sample Data
NumericVector A = NumericVector::create(10, 9, 8, 7, 6);
NumericVector B = NumericVector::create(5, 4, 3, 2, 1);

// --- Sample Vectorized Calls

NumericVector C = beta(A, B);
// Output: 9.99001e-005 0.000505051 0.00277778 0.0178571 0.166667

NumericVector D = lbeta(A, B);
// Output: -9.21134 -7.59085 -5.8861 -4.02535 -1.79176

// --- Optional Scalar

NumericVector E = beta(10, B);
// Output: 9.99001e-005 0.00034965 0.00151515 0.00909091 0.1

NumericVector F = beta(A, 5);
// Output: 9.99001e-005 0.0001554 0.000252525 0.0004329 0.000793651
```

---

#### Gamma {#gamma}

|                |                  |
|:---------------|:-----------------|
| **gamma( X )** | **lgamma( X )**  |

- Compute value of the gamma function, $\Gamma \left(x\right)$, and the natural 
  logarithm of the absolute value of the gamma function,
  $\log \left( {\left| {\Gamma \left( x \right)} \right|} \right)$.

- **Definition:**

$$\begin{aligned}
\Gamma \left( x \right) &= \int\limits_0^\infty  { {t^{\left( {x - 1} \right)} }\exp \left( { - t} \right)dt}  \\
\log \left( {\left| {\Gamma \left( x \right)} \right|} \right) &=  \log \left( {\left| { \int\limits_0^\infty  { {t^{\left( {x - 1} \right)} }\exp \left( { - t} \right)dt} } \right|} \right)
\end{aligned}$$

- Supported types are `Integer` or `Numeric` of a `Vector` or `Matrix`. 

- Examples:

```{Rcpp}
// Sample Data
NumericVector A = NumericVector::create(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5);

NumericVector B = gamma(A);
// Output: 1 0.886227 1 1.32934 2 3.32335 6 11.6317 24

NumericVector C = lgamma(A);
// Output: 0 -0.120782 0 0.284683 0.693147 1.20097 1.79176 2.45374 3.17805
```

#### Gamma Derivatives {#gamma-deriv}

|                            |                     |
|:---------------------------|:--------------------|
| **psigamma( X , deriv )**  |                     |
| **digamma( X )**           | **trigamma( X )**   |
| **tetragamma( X )**        | **pentagamma( X )** |

- Obtain the _n_^th^ derivative of the logarithm of the gamma function using
  `psigamma`. For convenience, derivatives of the second, `digamma`, through 
  fifth, `pentagamma`, order have been defined.

- **Definition:**
$$\begin{aligned}
  {\psi _n}\left( x \right) &= \frac{ { {d^{n + 1} } } }{ {d{x^{n + 1} } } }\ln \Gamma \left( x \right) \\
   &= \frac{ { {d^n} } }{ {d{x^n} } }\frac{ {\Gamma '\left( x \right)} }{ {\Gamma \left( x \right)} }  \\ 
\end{aligned}$$

- The `deriv` parameter of the `psigamma` function specifies the derivative
  to take of the logarithm of the gamma function.

- For the `psigamma` function, only the `Numeric` type of the `Vector` and 
  `Matrix` class is supported. The convenience derivative functions have support
  for both `Integer` and `Numeric` type of the `Vector` and `Matrix` class.

- Examples:

```{Rcpp}
NumericVector A = NumericVector::create(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5);

NumericVector B = digamma(A);
// Output: -0.577216 0.03649 0.422784 0.703157 0.922784 1.10316 1.25612 1.38887 1.50612

NumericVector C = trigamma(A);
// Output: 1.64493 0.934802 0.644934 0.490358 0.394934 0.330358 0.283823 0.248725 0.221323

NumericVector D = tetragamma(A);
// Output: -2.40411 -0.828797 -0.404114 -0.236204 -0.154114 -0.108204 -0.0800397 -0.0615568 -0.0487897

NumericVector E = pentagamma(A);
// Output: 6.49394 1.40909 0.493939 0.223906 0.118939 0.0703058 0.0448653 0.0303225 0.0214278

// --- Trigamma derivative
NumericVector F = psigamma(A, 1.0);
// Output: 1.64493 0.934802 0.644934 0.490358 0.394934 0.330358 0.283823 0.248725 0.221323
```

---

### Factorials {#factorials}

|                    |                     |
|:-------------------|:--------------------|
| **factorial( X )** | **lfactorial( X )** |

- Compute the product of all positive integers less than or equal to _n_ using
  `factorial` and the natural logarithm of the absolute value of the factorial
  with `lfactorial`.

- **Definition**: 
$$\begin{aligned}
n! &= \prod\limits_{k = 1}^n { {k_i} }  = 1 \times 2 \times  \cdots  \times \left( {n - 1} \right) \times n \\
&= \begin{cases}
1, &\text{if } n = 0 \\
n\left( {n - 1} \right)!, &\text{if } n > 0
\end{cases} \\
&= \Gamma\left(n+1\right) \\
\log \left( {\left| {n!} \right|} \right) &= \log \left( {\left| {\Gamma \left( {n + 1} \right)} \right|} \right)
\end{aligned}$$

- Only the `Numeric` type of the `Vector` and `Matrix` class is supported.

- Examples:

```{Rcpp}
// Sample Data
NumericVector A = NumericVector::create(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5);

NumericVector B = factorial(A);
// Output: 1 1.32934 2 3.32335 6 11.6317 24 52.3428 120

NumericVector C = lfactorial(A);
// Output: 0 0.284683 0.693147 1.20097 1.79176 2.45374 3.17805 3.95781 4.78749
```

### Combinatorics {#combinatorics}

|                        |                        |
|:-----------------------|:-----------------------|
| **choose( N , K )**    | **lchoose( N , K)**    |

- Compute the binomial coefficients for all real numbers _n_ and integer _k_ using
  `choose` and the natural logarithm of the absolute value of the binomial coefficients
  with `lchoose`.

- **Definition**: 
$$\begin{aligned}
{n \choose k} &= \frac{n!}{k!\left( {n - k} \right)!} = \frac{n\left( {n - 1} \right) \cdots \left( {n - k + 1} \right)}{k!} \\
\log \left( {\left| {n \choose k} \right|} \right) &= \log \left( {\left| {\frac{n\left( {n - 1} \right) \cdots \left( {n - k + 1} \right)}{k!} } \right|} \right)
\end{aligned}$$

- Only the `Numeric` type of the `Vector` and `Matrix` class is supported.

- Examples:

```{Rcpp choose_sugar}
// Sample Data
NumericVector A = NumericVector::create(10, 9, 8, 7, 6);
NumericVector B = NumericVector::create(5, 4, 3, 2, 1);

// --- Vectorize Choose

NumericVector C = choose(A, B);
// Output: 252 126 56 21 6

NumericVector D = lchoose(A, B);
// Output: 5.52943 4.83628 4.02535 3.04452 1.79176

// --- Scalar Choose

NumericVector E = choose(10.0, B);
// Output: 252 210 120 45 10

NumericVector F = choose(A, 5.0);
// Output: 252 126 56 21 6
```

---

### Statistical Summaries {#sugar-stats}

#### Minimum and Maximum {#min-max}

|              |              |
|:-------------|:-------------|
| **min( X )** | **max( X )** |

- Obtain the extremum value of either a maximum and minimum from within `Vector` 
  or `Matrix`. 

- Examples:

```{Rcpp min_v_max}
// Sample Data
NumericVector X = NumericVector::create(3, 4, 9, 5, 1, 2);

// Obtain max value for X
double X_max = max(X);
// Output: 9

// Obtain min value for X
double X_min = minx(X);
// Output: 1
```

---

#### range( X ) {#range}

- Computes the range or the minimum and maximum values of the sample.

- Supported types are `Integer` or `Numeric` of a `Vector` or `Matrix`. 

```{Rcpp range_vals}
// Sample Data
NumericVector X = NumericVector::create(3, 4, 9, 5, 1, 2);

// Obtain range value for X
NumericVector X_range = range(X);
// Output: 1 9
```

---

#### mean( X ) {#mean}

- Computes the overall sample mean by summing each observation and dividing
  by the total number of observations.
  
- Definition: $$\bar{X} = \frac{1}{n}\sum\limits_{i = 1}^n { {X_i} } $$

- Supported types are `Integer`, `Numeric`, `Complex`, or `Logical` of a
  `Vector` or `Matrix`. 

```{Rcpp mean_val}
// Sample Data
NumericVector X = NumericVector::create(3, 4, 9, 5, 1, 2);

// Obtain mean value for X
double X_mean = mean(X);
// Output: 4
```

- See also:
    - [`colMeans` / `rowMeans`](#matrix-mean)

---

#### median( X , na_rm) {#median}

- Computes the sample median by ordering elements from largest to smallest and
  then selecting the middle element. If an even number of elements is present,
  then the median consists of an average between the two middle numbers.

- All types of a `Vector` or `Matrix` are supported.

- Examples:

```{Rcpp median_val}
// Sample Data
NumericVector X = NumericVector::create(3,4,9,5,NA_REAL,1,2);

// Obtain the median value for X by removing NAs
double X_median = median(X, true);
// Output: 3.5

// By default, NA is not removed
double X_median_na = median(X);
// Output: NaN
```


---

#### Variance {#var}

|              |             |
|:-------------|:------------|
| **var( X )** | **sd( X )** |


- Computes the _sample_ variance and standard deviation formula by taking the
  corrected sum of squares and dividing it by $N-1$.
  
- Definition: $$\begin{aligned}
\operatorname{var}\left( X \right) &= \frac{1}{n-1}\sum\limits_{i = 1}^n { { {\left( { {X_i} - \bar X} \right)}^2} } \\
\operatorname{sd}\left( X \right) &= \sqrt{\operatorname{var}\left( X \right)}
\end{aligned}$$

- **Note:** No parameter support exists to switch between _population_ ($\frac{1}{n}$) 
  and _sample_ ($\frac{1}{n-1}$) definitions. If necessary, multiple by the
  multiplication by `double(n-1)/n` should provide the appropriate conversion.

- Supported types are `Integer`, `Numeric`, `Complex`, or `Logical` of a
  `Vector` or `Matrix`. 

```{Rcpp}
// Sample data
NumericVector X = NumericVector::create(5.3, 1.9, 7.4, 4.5, 2.5);

// --- Compute the Variance
double var_val = var(X);
// Output: 4.912

// --- Compute the SD
double sd_val = SD(X);
// Output: 2.216303
```

---

### Special Operations {#sugar-special-ops}

#### rev( X ) {#rev}

- Reverse the position of the elements within the vector.

- All types are supported of a `Vector` or `Matrix`.

- Example:

```{Rcpp rev_vec}
// Sample data
NumericVector A = NumericVector::create(1, 10, 100, 1000, 10000);

// --- Reverse the vector
NumericVector B = rev(A);
// Output: 10000  1000   100    10     1
```

----


#### Parallel Extremum {#pext}
|                   |                    |
|:------------------|:-------------------|
| **pmax( X, Y )**  | **pmin( X, Y )**   |

- Obtain a parallel extremum value of either maximum and minimum for either 
  a scalar and a `Vector` or just two `Vector` objects.
  
- For instance, the parallel minimum of X = 0, 1 and Y = 2, -3 would be Z = 0, -3.

- Examples:

```{Rcpp parallel_ext}
// Sample Data
NumericVector A = NumericVector::create(1,3,2,4,6,5);
NumericVector B = NumericVector::create(2,1,3,5,4,6);

// --- Parallel Maximum

// Scalar and Vector
NumericVector C = pmax(2, A);
// Output: 2 3 2 4 6 5

// Two vectors
NumericVector D = pmax(A, B);
// Output: 2 3 3 5 6 6

// --- Parallel Minimum

// Scalar and Vector
NumericVector E = pmin(2, A);
// Output: 1 2 2 2 2 2

// Two vectors
NumericVector F = pmin(A, B);
// Output: 1 1 2 4 4 5
```

#### clamp( min , X , max ) {#clamp}

- Bound elements of `X` between `min` and `max` by replacing the element by
  the boundary if $X < min$ or $X > max$.
  
- An alternate version of this function can be obtained with 
  `pmax(min, pmin(X, max) )`.

- Example:

```{Rcpp clamp_val}
// Sample Data
NumericVector A = NumericVector::create(-3.4, 5.1, -8.1, 10.8, 2.9, 4.3, 15.5);

// --- Clamp values

// Remove negative values and any value above 10
NumericVector C = clamp(0.0, A, 10.0);
// Output: 0.0 5.1 0.0 10.0 2.9 4.3 10.0
```

- See also:
   - [Rcpp Gallery: Using the Rcpp sugar function `clamp`](http://gallery.rcpp.org/articles/sugar-function-clamp/)
   - [`pmax`, `pmin`](#pext)

----

#### Extremum Indice {#which}

|                     |                    |
|:--------------------|:-------------------|
| **which_min( X )**  | **which_max( X )** |

- Provides the position in the vector of the minimum or maximum value.

- All types are supported of a `Vector` or a `Matrix`.

- Examples:

```{Rcpp ids_min_v_max}
// Sample data
NumericVector A = NumericVector::create(3.2, 5.2, -9.7, 4.3, 8.8);

// Return index for min value
int min_idx = which_min(A);
// Output: 2 (because C++ indices starts at 0!)

// Return index for max value
int max_idx = which_max(A);
// Output: 4 (because C++ indices starts at 0!)
```

- See also:
   - [`min`, `max`](#min-max)

----

### Uniqueness Operators {#sugarunique}

#### match( X ) {#match}

----

#### self_match( X ) {#self-match}

----

#### in( X, Y ) {#in}

----

#### Unique {#unique}

|                     |                 |
|:--------------------|:----------------|
| **duplicated( X )** | **unique( X )** |

- Determine whether duplicates exist within a `Vector` or what the unique values
  are.
  
- Duplicated values are identified by a `LogicalVector` such that the first,
  second, and so on replicates are labeled as `TRUE` while unique values are `FALSE`.
  
- Unique provides only the first occurrence of a given value. In essence, only
  the values that appear as `FALSE` within the `duplicate` function.

- Examples:

```{Rcpp unique_v_duplicates}
// Sample data
CharacterVector A = CharacterVector::create("a","b","c","a","b","c","a");

// Detect duplicates within a string
LogicalVector B = duplicated(A);
// Output: FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE

// Obtain only unique values
CharacterVector C = unique(A);
// Output: "a", "b", "c"
```

----

### sort_unique( X ) {#sort_unique}

----

### table( X ) {#table}

- Given a `Vector` of either `NumericVector`, `IntegerVector`, `LogicalVector`,
  or `CharacterVector`, compute an `IntegerVector` that contains a count of
  each value.

- Examples:

```{Rcpp rcpp_table}
// Needs to have a way to extract what value is represented at each position
// names attribute? 

// Create Numerical Data
NumericVector A = NumericVector::create(3.2, 1.2, -0.5, NA_REAL, 1.2, 2.0, NA_REAL);

// Tabulate
IntegerVector B = table(A);

// Create Integer Data
IntegerVector C = IntegerVector::create(2, -2, NA_INTEGER, NA_INTEGER, 200, 2);

// Tabulate the integer data
IntegerVector D = table(C);

// Create Character Data
CharacterVector E = CharacterVector::create("a", "a", "b", NA_STRING, "c", NA_STRING);

// Tabulate
IntegerVector F = table(E);

// Create Logical Data
LogicalVector G = LogicalVector::create(true, NA_LOGICAL, false, true, NA_LOGICAL);

// Tabulate
IntegerVector H = table(G);
```

----

### Set Operations {#sugar-set-ops}

#### setequal(X, Y) {#setequal}

- Determine if the values of two objects are equal.

- **Definition:** \[A = B = \left\{ {\forall x:x \in A \wedge x \in B} \right\}\]

- All types are supported of a `Vector` or `Matrix`.

- Examples:

```{Rcpp set_equal}
// Sample Data for equal case
CharacterVector A = CharacterVector::create("a", "b", "c");
CharacterVector B = CharacterVector::create("c", "b", "a");

// Sample Data for unequal case
CharacterVector C = CharacterVector::create("a", "b");
CharacterVector D = CharacterVector::create("c");

bool val_equal_set = setequal(A, B);
// Output: TRUE

bool val_unequal_set = setequal(C, D);
// Output: FALSE
```

----

#### intersect(X, Y) {#intersect}

- Find all elements two objects have in common.

- **Definition:** \[A \cap B = \left\{ {x:x \in A \wedge x \in B} \right\}\]

- All types are supported of a `Vector` or `Matrix`.

- Examples:

```{Rcpp set_intersect}
// Sample Data for equal case
CharacterVector A = CharacterVector::create("a", "b", "c");
CharacterVector B = CharacterVector::create("c", "b", "d");

// Sample Data for empty set
CharacterVector C = CharacterVector::create("a", "b");
CharacterVector D = CharacterVector::create("c");

CharacterVector E = intersect(A, B);
// Output: "b" "c"

CharacterVector F = intersect(C, D);
// Output: 
// (Empty set/None)
```

----

#### union_(X, Y) {#union}

- Obtaining only one copy of all elements that exist in both sets.

- **Definition:** \[A \cup B = \left\{ {x:x \in A \vee x \in B} \right\}\]

- All types are supported of a `Vector` or `Matrix`.

- **Note:** Union has a postfix of an underscore (`_`) because
   `union` is a keyword in C++.

- Examples:

```{Rcpp set_union}
// Sample Data for overlapping elements
CharacterVector A = CharacterVector::create("a", "b", "c");
CharacterVector B = CharacterVector::create("c", "b", "d");

// Sample Data for no shared elements
CharacterVector C = CharacterVector::create("a", "b");
CharacterVector D = CharacterVector::create("c");

// --- Calling union_

CharacterVector E = union_(A, B);
// Output: "d" "a" "c" "b"

CharacterVector F = union_(C, D);
// Output: "a" "c" "b"
```

----

#### setdiff(X, Y) {#setdiff}

- Obtain the elements in _A_ not in _B_ or the intersection of _A_ with the 
  complement of _B_.

- **Definition:** \[A\backslash B = A - B = A \cap {B^C} = \left\{ {x:x \in A \wedge x \notin B} \right\}\]

- All types are supported of a `Vector` or `Matrix`.

- Examples:

```{Rcpp set_diff}
// Sample Data for overlapping elements
CharacterVector A = CharacterVector::create("a", "b", "c");
CharacterVector B = CharacterVector::create("c", "b", "d");

// Sample Data for no shared elements
CharacterVector C = CharacterVector::create("a", "b");
CharacterVector D = CharacterVector::create("c");

// --- Calling setdiff

CharacterVector E = setdiff(A, B);
// Output: "a"

// Note order results in different values!
CharacterVector F = setdiff(B, A);
// Output: "d"

CharacterVector G = setdiff(C, D);
// Output: "a" "b"
```

----


### Matrix Operations {#sugar-matrix-ops}

#### Row and Column Sums {#matrix-sum}

|                          |                          |
|:-------------------------|:-------------------------|
| **colSums( X , na_rm)**  | **rowSums( X , na_rm )** |

- Computes the summation of elements either by column (`colSums`) or row (`rowSums`)
  of a `Matrix`.

- **Definition:**

\[\begin{aligned}
  \text{(Row) } { {X}_{i} } &= \sum\limits_{j = 1}^J { {X_{i,j} }} \\
  \text{(Column) } { {X}_{j} } &= \sum\limits_{i = 1}^I { {X_{i,j} }} \\ 
\end{aligned} \]

- Supported types are `Numeric`, `Integer` or `Complex` of the `Matrix` class.

- The return type is the equivalent input type but of the `Vector` class.

- Examples:

```{Rcpp}
NumericVector A = NumericVector::create(1.0, 2.0, 3.0, 4.0);
NumericMatrix B = NumericMatrix(2, 2, A.begin());
// Output:
// 1.00000 3.00000
// 2.00000 4.00000

// --- Various matrix sums

NumericVector C = colSums(B);
// Output: 3 7

NumericVector D = rowSums(B);
// Output: 4 6
```

- See also:
    - [`sum`](#sum)

----

#### Row and Column Means {#matrix-mean}

|                           |                          |
|:--------------------------|:-------------------------|
| **colMeans( X , na_rm)**  | **rowMeans( X , na_rm)** |


- Computes the means of elements either by column (`colMeans`) or row (`rowMeans`)
  of a `Matrix`.
  
- **Definition:**

\[\begin{aligned}
  \text{(Row) } { {\bar X}_{i} } &= \frac{1}{J}\sum\limits_{j = 1}^J { {X_{i,j} }} \\
  \text{(Column) }{ {\bar X}_{j} } &= \frac{1}{I}\sum\limits_{i = 1}^I { {X_{i,j} }} \\ 
\end{aligned} \]
  
- Supported types are `Numeric`, `Integer` or `Complex` of the `Matrix` class.

- The return type is the equivalent input type but of the `Vector` class.

- Examples:

```{Rcpp}
NumericVector A = NumericVector::create(1.0, 2.0, 3.0, 4.0);
NumericMatrix B = NumericMatrix(2, 2, A.begin());
// Output:
// 1.00000 3.00000
// 2.00000 4.00000

// --- Various matrix means

NumericVector C = colMeans(B);
// Output: 1.5 3.5

NumericVector D = rowMeans(B);
// Output: 2 3
```

- See also:
    - [`mean`](#mean)

----

#### outer( X , Y , Function) {#outer}


- Applies a `Function` to two `Vector` objects to obtain the outer product.

- **Definition:** \[\begin{aligned}
  f\left( {\vec u \otimes \vec v} \right) &= f\left( {\vec u{ {\vec v}^T} } \right) = f\left( {\left[ {\begin{array}{*{20}{c} }
  { {u_1} } \\ 
   \vdots  \\ 
  { {u_n} } 
\end{array} } \right]\left[ {\begin{array}{*{20}{c} }
  { {v_1} }& \cdots &{ {v_n} } 
\end{array} } \right]} \right) \hfill \\
   &= \left[ {\begin{array}{*{20}{c} }
  {f\left( { {u_1}{v_1} } \right)}&{f\left( { {u_1}{v_2} } \right)}& \cdots &{f\left( { {u_1}{v_n} } \right)} \\ 
  {f\left( { {u_2}{v_1} } \right)}&{f\left( { {u_2}{v_2} } \right)}&{}&{f\left( { {u_2}{v_n} } \right)} \\ 
   \vdots &{}& \ddots & \vdots  \\ 
  {f\left( { {u_n}{v_1} } \right)}&{f\left( { {u_n}{v_2} } \right)}&{}&{f\left( { {u_n}{v_n} } \right)} 
\end{array} } \right] \hfill \\ 
\end{aligned}\]
  
- All types of the `Vector` class are supported. However, the supplied `Function`
  must have the correct parameter input types to receive values from each `Vector`.

- The returned value is a `Matrix` class with its type given by the valued returned by the `Function`.

- The `Function` parameter also accepts a C++ `functor` in place of an Rcpp `Function`.
  In such cases, the underlying type _T_ must be defined. Select one of the following arguments for _T_:
    - `int` 
    - `double`
    - `std::complex<double> / Rcomplex` 
    - `bool`

- `Numeric` Output

| Functor                    | Meaning              |
|:---------------------------|:---------------------|
| `std::plus<T>()`           |   `x + y`            |
| `std::minus<T>()`          |   `x - y`            |
| `std::multiplies<T>()`     |   `x * y`            |
| `std::divides<T>()`        |   `x / y`            |
| `std::modulus<T>()`        |   `x % y`            |

- `Logical` Output

| Functor                    | Meaning              |
|:---------------------------|:---------------------|
| `std::equal_to<T>()`       |   `x == y`           |
| `std::not_equal_to<T>()`   |   `x != y`           |
| `std::greater<T>()`        |   `x > y`            |
| `std::less<T>()`           |   `x < y`            |
| `std::greater_equal<T>()`  |   `x >= y`           |
| `std::less_equal<T>()`     |   `x <= y`           |


- Examples:

```{Rcpp}
// Sample Data
NumericVector A = NumericVector::create(0.5, 1.0, 1.5, 2.0);
NumericVector B = NumericVector::create(0.0, 0.5, 1.0, 1.5);

// --- Applying outer with functors

NumericMatrix C = outer(A, B, std::plus<double>());
// Output:
//  0.5  1.0  1.5  2.0
//  1.0  1.5  2.0  2.5
//  1.5  2.0  2.5  3.0
//  2.0  2.5  3.0  3.5

LogicalMatrix D = outer(A, B, std::less<double>());
// Output:
// FALSE FALSE  TRUE  TRUE
// FALSE FALSE FALSE  TRUE
// FALSE FALSE FALSE FALSE
// FALSE FALSE FALSE FALSE
```

- See also:
    - [cppreference: Operator function objects](http://en.cppreference.com/w/cpp/utility/functional#Operator_function_objects)

----

#### Triangle Matrix Views {#tri-mat}

|                           |                           |
|:--------------------------|:--------------------------|
| **lower_tri( X , diag)**  | **upper_tri( X , diag )** |

- Creates a `Matrix` of `Logical` values of the same dimensions as the supplied
  `Matrix` with values in the lower or upper triangle portion being `true`.
  
- All types are supported of the `Matrix` class.

- By default, the `diag` parameter is `false` and, therefore, does _not_ 
  include the major diagonal (upper left to lower right).
  
- **Note:** Prior to Rcpp 0.13.0, neither the `upper_tri` or the `lower_tri`
  function worked.

- Examples:

```{Rcpp}
NumericVector A = NumericVector::create(1, 2, 3, 4, 5, 6, 7, 8, 9);
NumericMatrix B = NumericMatrix(3, 3, A.begin());
// Output:
// 1.00000 4.00000 7.00000
// 2.00000 5.00000 8.00000
// 3.00000 6.00000 9.00000

// --- Lower Triangular Matrix

LogicalMatrix E = lower_tri(B);
// Output:
// FALSE FALSE FALSE
//  TRUE FALSE FALSE
//  TRUE  TRUE  TRUE

LogicalMatrix F = lower_tri(B, true);
// Output:
// TRUE FALSE FALSE
// TRUE  TRUE FALSE
// TRUE  TRUE  TRUE

// --- Upper Triangular Matrix

LogicalMatrix C = upper_tri(B);
// Output:
// FALSE  TRUE  TRUE
// FALSE FALSE  TRUE
// FALSE FALSE FALSE

LogicalMatrix D = upper_tri(B, true);
// Output:
//  TRUE  TRUE  TRUE
// FALSE  TRUE  TRUE
// FALSE FALSE  TRUE
```

----

#### diag( X ) {#diag}

- Extracts the major diagonal going from the upper left to lower right of a
  `Matrix`.
  
- All types of the `Matrix` class are supported.

- The return type is a `Vector` of an equivalent type to the input `Matrix`.

- Example:

```{Rcpp}
NumericVector A = NumericVector::create(1, 2, 3, 4, 5, 6, 7, 8, 9);
NumericMatrix B = NumericMatrix(3, 3, A.begin());
// Output:
// 1.00000 4.00000 7.00000
// 2.00000 5.00000 8.00000
// 3.00000 6.00000 9.00000

NumericVector C = diag(B);
// Output: 1 5 9
```


----

#### Matrix Indexes {#idx-mat}

|               |              |
|:--------------|:-------------|
| **col( X )**  | **row( X )** |


- Creates a `Matrix` where each element contains either a 1-based index for its
  column (`col`) or row (`row`).
  
- All types of the `Matrix` class are supported.

- The return type is an `IntegerMatrix`.

- Examples:

```{Rcpp}
NumericVector A = NumericVector::create(1.0, 2.0, 3.0, 4.0);
NumericMatrix B = NumericMatrix(2, 2, A.begin());
// Output:
// 1.00000 3.00000
// 2.00000 4.00000

// --- Various Matrix Indexes

IntegerMatrix C = col(B);
// Output:
// 1 2
// 1 2


IntegerMatrix D = row(B);
// Output:
// 1 1
// 2 2
```

----

### Object Creation {#sugar-object-creation}

#### cbind {#cbind}

|                      |
|:---------------------|
| **cbind(X, Y)**      |
| **cbind(X, Y, ...)** |


**cbind(X, Y, ...)**

- Creates a `Matrix` by joining objects together in a column-wise manner. 

- *X*, *Y* may be any combination of `Vector`, `Matrix`, or atomic value 
  of the same underlying type *T*, where *T* is one of 
    - `int` 
    - `double`
    - `std::complex<double> / Rcomplex` 
    - `bool`
    
- `cbind` is defined for any number of arguments between 2 and 50, inclusive. 

- Let *S1* and *S2* be scalar (atomic) values, *V* be a `Vector` with length k,
  and *M* be a `Matrix` with with m rows and n columns. The `cbind` function 
  exhibits the following behavior: 
    - `cbind(S1, S2)` returns a 1 x 2 `Matrix`.
    - `cbind(S1, V)` and `cbind(V, S1)` return a k x 2 `Matrix`, where *S1* is 
      recycled k times.
    - `cbind(S1, M)` and `cbind(M, S1)` return an m x (n + 1) `Matrix`, where 
      `S1` is recycled m times.
    - If k and m are equal, `cbind(V, M)` and `cbind(M, V)` return an m x n 
      `Matrix`.
    - If k and m are not equal, `cbind(V, M)` and `cbind(M, V)` will throw an 
      exception at runtime. 
    - *S1* and *S2* may be consecutive arguments in a `cbind` expression IFF:
        - they are the *only* arguments used; or
        - all other arguemnts are also scalars; or
        - non-scalar, adjacent arguments are vectors of length one, or matrices 
          with one row.
    - All other cases involving consecutive arguments *S1* and *S2* will 
      generate a runtime error.
      
- Examples: 
          
```{Rcpp, cbind}
double d = 1.0;
NumericVector v(3, 2.0);
NumericMatrix m(3, 2); 
m.fill(3.0);

Rcout 
    << std::setprecision(2) 
    << "cbind(1.5, 2.5):\n" << cbind(1.5, 2.5) << "\n"
    << "cbind(d, v):\n" << cbind(d, v) << "\n"
    << "cbind(v, d):\n" << cbind(v, d) << "\n"
    << "cbind(d, v, m, v, d):\n" << cbind(d, v, m, v, d) 
    << std::endl;
// Output:
// cbind(1.5, 2.5):
// 1.5 2.5
// 
// cbind(d, v):
// 1.0 2.0
// 1.0 2.0
// 1.0 2.0
// 
// cbind(v, d):
// 2.0 1.0
// 2.0 1.0
// 2.0 1.0
// 
// cbind(d, v, m, v, d):
// 1.0 2.0 3.0 3.0 2.0 1.0
// 1.0 2.0 3.0 3.0 2.0 1.0
// 1.0 2.0 3.0 3.0 2.0 1.0
```

#### Sequence Generation {#seq}

|                     |                      |
|:--------------------|:---------------------|
| **seq_along( X )**  | **seq_len( n )**     |

- Generate an `Integer` sequence with the index beginning at 1 either based on 
  an object (`seq_along`) or length (`seq_len`).
  
- All types are supported of a `Vector` or `Matrix`.

- The return type is that of an `IntegerVector`.
 
- Examples:

```{Rcpp}
NumericVector A = NumericVector::create(-1, 0, 1);

// By default, seq_along returns R indices
IntegerVector B = seq_along(A);
// Output: 1 2 3

// Generates a vector of specified length
IntegerVector C = seq_len(5);
// Output: 1 2 3 4 5
```


----

#### Replicate Elements {#rep}

|                     |                      |                      |
|:--------------------|:---------------------|:---------------------|
| **rep( X, n )**     | **rep_each( X, n )** | **rep_len( X, n )**  |

- Replicate elements in three flavors: 
    - `rep`: duplicate the object _n_ times retaining the initial element order.
    - `rep_each`: each element is repeated _n_ times consecutively.
    - `rep_len`: duplicate object until the new object has length of _n_.

- All types are supported of a `Vector` or `Matrix`.

- Examples:

```{Rcpp}
NumericVector A = NumericVector::create(-1, 0, 1);

NumericVector B = rep(A, 3);
// Output: -1 0 1 -1 0 1 -1 0 1

NumericVector C = rep_each(A, 3);
// Output: -1 -1 -1 0 0 0 1 1 1

NumericVector D = rep_len(A, 5);
// Output: -1 0 1 -1 0
```

### String Operations {#sugar-string-ops}

#### collapse( X ) {#collapse}

- Collapse multiple strings values into a single string.

- Only the `Character` and `String` types of a `Vector` or `Matrix` are
  supported.

- **Note:** The function is equivalent to `paste(c('a', 'b'), collapse = "")`.

- Example:

```{Rcpp sugar_collapse}
CharacterVector A = CharacterVector::create("w","o","r","l","d");

std::string val_str = collapse(A);
// Output: world
```

----

## Statistical Distributions {#stat-dist}

- There exists two approaches for working with statistical distribution functions
  within Rcpp. The approaches differ on how the result is returned. Specifically,
  statistical distributions within the `Rcpp::` namespace return type
  `NumericVector` whereas functions within the `R::` namespace return a single 
  `double` scalar value.
  
- For drawing large samples with fixed distribution parameters, sampling under
  one should sample under the `Rcpp::` namespace to obtain a `NumericVector`.
  There is an added benefit to working under this scheme of having default
  parameters for log probability and lower tail sampling akin to traditional R
  versions.

- For drawing samples with changing distribution parameters, sampling under
  the `R::` namespace with a `for` loop is perferred as parameters for
  each draw can be customized.


### Discrete Distributions {#discrete-dist}

#### Binomial Distribution {#bin-dist}

|                                                 |
|:------------------------------------------------|
| **dbinomial(X, SIZE, PROB, LOG_P)**             |
| **pbinomial(Q, SIZE, PROB, LOWER_TAIL, LOG_P)** |
| **qbinomial(P, SIZE, PROB, LOWER_TAIL, LOG_P)** |
| **rbinomial(N, SIZE, PROB)**                    |


```{Rcpp rcpp_bin_dist}
// Consider X ~ Bin(n = 100, p = 0.5)

IntegerVector xx = IntegerVector::create(46, 47, 48, 49, 50, 51, 52, 53, 54);

// Vector returns
NumericVector densities = Rcpp::dbinom(xx, 100, .5, false)
NumericVector probs     = Rcpp::pbinom(xx, 100, .5, true, false);
NumericVector qvals     = Rcpp::qbinom(probs, 100, .5, true, false);
NumericVector rsamples  = Rcpp::rbinom(20, 100, .5); 

// Scalar Returns
double dval  = R::dbinom(46, 100, .5, false);
double pval  = R::pbinom(46, 100, .5, true, false);
double qval  = R::qbinom(0.242, 100, .5, true, false);
int rdraw = R::rbinom(46, 100);
```


#### Geometric Distribution {#geo-dist}

|                                       |
|:--------------------------------------|
| **dgeom(X, PROB, LOG_P)**             |
| **pgeom(Q, PROB, LOWER_TAIL, LOG_P)** |
| **qgeom(P, PROB, LOWER_TAIL, LOG_P)** |
| **rgeom(N, PROB)**                    |


```{Rcpp rcpp_geo_dist}
// Consider X ~ Geom(p = 0.25)
IntegerVector xx = seq_len(5);

// Vector returns
NumericVector densities = Rcpp::dgeom(xx, .25, false)
NumericVector probs     = Rcpp::pgeom(xx, .25, true, false);
IntegerVector qvals     = Rcpp::qgeom(probs, .25, true, false);
IntegerVector rsamples  = Rcpp::rgeom(20, .25); 

// Scalar Returns
double dval  = R::dgeom(2, .25, false);
double pval  = R::pgeom(2, .25, true, false);
int qval     = R::qgeom(0.578125, .25, true, false);
int rdraw    = R::rgeom(.25);
```

#### Hypergeometric Distribution {#hypergeo-dist}

|                                            |
|:-------------------------------------------|
| **dhyper( X, M, N, K, LOG_P)**             |
| **phyper( Q, M, N, K, LOWER_TAIL, LOG_P)** |
| **qhyper( P, M, N, K, LOWER_TAIL, LOG_P)** |
| **rhyper(NN, M, N, K)**                    |


```{Rcpp rcpp_hypergeo_dist}
// Consider X ~ Hypergeo(m = 10, n = 7, k = 8)
IntegerVector xx = IntegerVector::create(3, 4, 5, 6, 7);

// Vector returns
NumericVector densities = Rcpp::dhyper(xx, 10, 7, 8, false)
NumericVector probs     = Rcpp::phyper(xx, 10, 7, 8, true, false);
NumericVector qvals     = Rcpp::qhyper(probs, 10, 7, 8, true, false);
NumericVector rsamples  = Rcpp::rhyper(20, 10, 7, 8); 

// Scalar Returns
double dval  = R::dhyper(46, 10, 7, 8, false);
double pval  = R::phyper(46, 10, 7, 8, true, false);
int qval     = R::qhyper(0.4193747, 10, 7, 8, true, false);
int rdraw    = R::rhyper(10, 7, 8);
```

#### Negative Binomial Distribution {#negbin-dist}

|                                                  |
|:-------------------------------------------------|
| **dnbinomial(X, SIZE, PROB, LOG_P)**             |
| **pnbinomial(Q, SIZE, PROB, LOWER_TAIL, LOG_P)** |
| **qnbinomial(P, SIZE, PROB, LOWER_TAIL, LOG_P)** |
| **rnbinomial(N, SIZE, PROB)**                    |


```{Rcpp rcpp_nbin_dist}
// Consider X ~ NegBin(n = 100, p = 0.5)
IntegerVector xx = IntegerVector::create(46, 47, 48, 49, 50, 51, 52, 53, 54);

// Vector returns
NumericVector densities = Rcpp::dnbinom(xx, 100, .5, false)
NumericVector probs     = Rcpp::pnbinom(xx, 100, .5, true, false);
NumericVector qvals     = Rcpp::qnbinom(probs, 100, .5, true, false);
NumericVector rsamples  = Rcpp::rnbinom(20, 100, .5); 

// Scalar Returns
double dval  = R::dnbinom(46, 100, .5, false);
double pval  = R::pnbinom(46, 100, .5, true, false);
double qval  = R::qnbinom(0.242, 100, .5, true, false);
int rdraw    = R::rnbinom(46, 100);
```

#### Poisson Distribution {#pois-dist}

|                                         |
|:----------------------------------------|
| **dpois(X, LAMBDA, LOG_P)**             |
| **ppois(Q, LAMBDA, LOWER_TAIL, LOG_P)** |
| **qpois(P, LAMBDA, LOWER_TAIL, LOG_P)** |
| **rpois(N, LAMBDA)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Poisson distribution.
  
- When simulating a vector or scalar from a Poisson distribution,
  the value returned is within the natural numbers (e.g. $0, 1, 2, \ldots , 42, \ldots , \mathbb{N}$).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_pois_dist}
// Consider X ~ Pois(4)
IntegerVector xx = seq_len(10);

// Vector returns
NumericVector densities = Rcpp::dpois(xx, 4, false)
NumericVector probs     = Rcpp::ppois(xx, 4, true, false);
NumericVector qvals     = Rcpp::qpois(probs, 4, true, false);
NumericVector rsamples  = Rcpp::rpois(20, 4); 

// Scalar Returns
double dval  = R::dpois(46, 4, false);
double pval  = R::ppois(46, 4, true, false);
double qval  = R::qpois(0.242, 4, true, false);
int rdraw    = R::rpois(46);
```

### Wilcox Distribution {#wilcox-dist}

|                                          |
|:-----------------------------------------|
| **dwilcox( X, M, N, LOG_P)**             |
| **pwilcox( Q, M, N, LOWER_TAIL, LOG_P)** |
| **qwilcox( P, M, N, LOWER_TAIL, LOG_P)** |
| **rwilcox(NN, M, N)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Wilcox distribution.
  
- When simulating a vector or scalar from a Wilcox distribution,
  the value returned is within the natural numbers (e.g. $0, 1, 2, \ldots , 42, \ldots , \mathbb{N}$).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:


### Wilcoxon Signed Rank Distribution {#signed-dist}

|                                         |
|:----------------------------------------|
| **dsignrank( X, N, LOG_P)**             |
| **psignrank( Q, N, LOWER_TAIL, LOG_P)** |
| **qsignrank( P, N, LOWER_TAIL, LOG_P)** |
| **rsignrank(NN, N)**                    |


### Continuous Distributions {#continuous-dist}

#### Beta Distribution {#beta-dist}

|                                                 |
|:------------------------------------------------|
| **dbeta(X, SHAPE1, SHAPE2, LOG_P)**             |
| **pbeta(Q, SHAPE1, SHAPE2, LOWER_TAIL, LOG_P)** |
| **qbeta(P, SHAPE1, SHAPE2, LOWER_TAIL, LOG_P)** |
| **rbeta(N, SHAPE1, SHAPE2)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Beta distribution.
  
- When simulating a vector or scalar from a Beta distribution,
  the value returned is within [0, 1].

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_beta_dist}
// Consider X ~ Beta(1,1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dbeta(xx, 1.0, 1.0, false);
NumericVector probs     = Rcpp::pbeta(xx, 1.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qbeta(probs, 1.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rbeta(5, 1.0, 1.0);

// Scalar Returns
double dval  = R::dbeta(0.5, 1.0, 1.0, false);
double pval  = R::pbeta(0.5, 1.0, 1.0, true, false);
double qval  = R::qbeta(0.85, 1.0, 1.0, true, false);
double rdraw = R::rbeta(1.0, 1.0);
```


#### Cauchy Distribution {#cauchy-dist}

|                                                    |
|:---------------------------------------------------|
| **dcauchy(X, LOCATION, SCALE, LOG_P)**             |
| **pcauchy(Q, LOCATION, SCALE, LOWER_TAIL, LOG_P)** |
| **qcauchy(P, LOCATION, SCALE, LOWER_TAIL, LOG_P)** |
| **rcauchy(N, LOCATION, SCALE)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Cauchy distribution.
  
- When simulating a vector or scalar from a Cauchy distribution,
  the value returned is within (-infty, infty).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_cauchy_dist}
// Consider X ~ Cauchy(loc = 0, SCALE = 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dcauchy(xx, 0.0, 1.0, false)
NumericVector probs     = Rcpp::pcauchy(xx, 0.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qcauchy(probs, 0.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rcauchy(20, 0.0, 1.0); 

// Scalar Returns
double dval  = R::dcauchy(0.25, 0.0, 1.0, false);
double pval  = R::pcauchy(0.25, 0.0, 1.0, true, false);
double qval  = R::qcauchy(0.578, 0.0, 1.0, true, false);
double rdraw = R::rcauchy(0.0, 1.0);
```


#### Chi-square Distribution {#chisquare-dist}

|                                      |
|:-------------------------------------|
| **dchisq(X, DF, LOG)**               |
| **pchisq(Q, DF, LOWER_TAIL, LOG_P)** |
| **qchisq(P, DF, LOWER_TAIL, LOG_P)** |
| **rchisq(N, DF)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Chi-squared distribution.
  
- When simulating a vector or scalar from a Chi-squared distribution,
  the value returned is within [0, infty).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as log(p).
    - `LOWER_TAIL = TRUE`, probabilities are calculated by P(X <= x) instead of P(X > x).

- Examples:

```{Rcpp rcpp_chisq_dist}
// Consider X ~ X^2(df = 2)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dchisq(xx, 2, false)
NumericVector probs     = Rcpp::pchisq(xx, 2, true, false);
NumericVector qvals     = Rcpp::qchisq(probs, 2, true, false);
NumericVector rsamples  = Rcpp::rchisq(20, 2); 

// Scalar Returns
double dval  = R::dchisq(0.25, 2, false);
double pval  = R::pchisq(0.5, 2, true, false);
double qval  = R::qchisq(0.22, 2, true, false);
double rdraw = R::rchisq(2);
```

#### Non-central Chi-square Distribution {#nchisquare-dist}

|                                            |
|:-------------------------------------------|
| **dnchisq(X, DF, NCP, LOG_P)**             |
| **pnchisq(Q, DF, NCP, LOWER_TAIL, LOG_P)** |
| **qnchisq(P, DF, NCP, LOWER_TAIL, LOG_P)** |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Non-central Chi-squared
  distribution.
  
- When simulating a vector or scalar from a Non-central Chi-squared distribution,
  the value returned is within $\left[0, \infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_nchisq_dist}
// Consider X ~ X^2(df = 2, ncp = 2.5)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dchisq(xx, 2, 2.5, false)
NumericVector probs     = Rcpp::pchisq(xx, 2, 2.5, true, false);
NumericVector qvals     = Rcpp::qchisq(probs, 2, 2.5, true, false);

// Scalar Returns
double dval  = R::dnchisq(0.25, 2, false);
double pval  = R::pnchisq(0.5, 2, true, false);
double qval  = R::qnchisq(0.22, 2, true, false);
```

#### Exponential Distribution {#exp-dist}

|                                      |
|:-------------------------------------|
| **dexp(X, RATE, LOG_P)**             |
| **pexp(Q, RATE, LOWER_TAIL, LOG_P)** |
| **qexp(P, RATE, LOWER_TAIL, LOG_P)** |
| **rexp(N, RATE)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from an Exponential distribution under
  the lambda parameterization: f(v) = lambda x exp(-lambda x v)
  
- When simulating a vector or scalar from an Exponential distribution, the value returned
  is within $\left[0, \infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `RATE = 1`, rate refers to the lambda parameter within an exponential
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_exp_dist}
// Consider X ~ Exp(Rate = 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dexp(xx, 1.0, false)
NumericVector probs     = Rcpp::pexp(xx, 1.0, true, false);
NumericVector qvals     = Rcpp::qexp(probs, 1.0, true, false);
NumericVector rsamples  = Rcpp::rexp(20, 1.0); 

// Scalar Returns
double dval  = R::dexp(0.25, 2, false);
double pval  = R::pexp(0.5, 2, true, false);
double qval  = R::qexp(0.22, 2, true, false);
double rdraw = R::rexp(2);
```


#### F Distribution {#f-dist}

|                                        |
|:---------------------------------------|
| **df(X, DF1, DF2, LOG_P)**             |
| **pf(Q, DF1, DF2, LOWER_TAIL, LOG_P)** |
| **qf(P, DF1, DF2, LOWER_TAIL, LOG_P)** |
| **rf(N, DF1, DF2)**                    |


- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from an F distribution.
  
- When simulating a vector or scalar from an F distribution, the value returned
  is within [0, infty).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_f_dist}
// Consider X ~ F(1, 5)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::df(xx, 1.0, 5.0, false);
NumericVector probs     = Rcpp::pf(xx, 1.0, 5.0 true, false);
NumericVector qvals     = Rcpp::qf(probs, 1.0, 5.0, true, false);
NumericVector rsamples  = Rcpp::rf(20, 1.0, 5.0); 

// Scalar Returns
double dval  = R::df(0.25, 1.0, 5.0, false);
double pval  = R::pf(0.5, 1.0, 5.0, true, false);
double qval  = R::qf(0.49, 1.0, 5.0, true, false);
double rdraw = R::rf(1.0, 5.0);
```

#### Non-central F Distribution {#nf-dist}



#### Gamma Distribution {#gamma-dist}

|                                               |
|:----------------------------------------------|
| **dgamma(X, SHAPE, RATE, LOG_P)**             |
| **pgamma(Q, SHAPE, RATE, LOWER_TAIL, LOG_P)** |
| **qgamma(P, SHAPE, RATE, LOWER_TAIL, LOG_P)** |
| **rgamma(N, SHAPE, RATE)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Gamma distribution.
  
- When simulating a vector or scalar from a Gamma distribution, the value returned
  is within $\left[0, \infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `RATE = 1`,
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:
 
```{Rcpp rcpp_gamma_dist}
// Consider X ~ Gamma(1, 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dgamma(xx, 1.0, 1.0, false);
NumericVector probs     = Rcpp::pgamma(xx, 1.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qgamma(probs, 1.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rgamma(20, 1.0, 1.0); 

// Scalar Returns
double dval  = R::dgamma(0.25, 1.0, 1.0, false);
double pval  = R::pgamma(0.5, 1.0, 1.0, true, false);
double qval  = R::qgamma(0.393, 1.0, 1.0, true, false);
double rdraw = R::rgamma(1.0, 1.0);
```

### Normal Distribution {#normal-dist}

|                                           |
|:------------------------------------------|
| **dnorm(X, MEAN, SD, LOG_P)**             |
| **pnorm(Q, MEAN, SD, LOWER_TAIL, LOG_P)** |
| **qnorm(P, MEAN, SD, LOWER_TAIL, LOG_P)** |
| **rnorm(N, MEAN, SD)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Normal distribution.
  
- When simulating a vector or scalar from a Normal distribution, the value returned
  is within $\left(-\infty, \infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `MEAN = 0`, the mean of the distribution
    - `SD = 1`, the standard derivation of the distribution
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:
 
```{Rcpp rcpp_normal_dist}
// Consider X ~ Norm(0, 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dnorm(xx, 0.0, 1.0, false);
NumericVector probs     = Rcpp::pnorm(xx, 0.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qnorm(probs, 0.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rnorm(20, 0.0, 1.0); 

// Scalar Returns
double dval  = R::dnorm(0.25, 0.0, 1.0, false);
double pval  = R::pnorm(0.95, 0.0, 1.0, true, false);
double qval  = R::qnorm(1.96, 0.0, 1.0, true, false);
double rdraw = R::rnorm(0.0, 1.0);
```


### Log Normal Distribution {#lognormal-dist}

|                                                  |
|:-------------------------------------------------|
| **dlnorm(X, MEANLOG, SDLOG, LOG_P)**             |
| **plnorm(Q, MEANLOG, SDLOG, LOWER_TAIL, LOG_P)** |
| **qlnorm(P, MEANLOG, SDLOG, LOWER_TAIL, LOG_P)** |
| **rlnorm(N, MEANLOG, SDLOG)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Log Normal distribution.
  
- When simulating a vector or scalar from a Log Normal distribution, the value returned
  is within $\left[0,\infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `MEANLOG = 0`, the log mean of the distribution
    - `SDLOG = 1`, the log standard derivation of the distribution
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:
 
```{Rcpp rcpp_lnorm_dist}
// Consider X ~ LogNorm(0, 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dlnorm(xx, 0.0, 1.0, false);
NumericVector probs     = Rcpp::plnorm(xx, 0.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qlnorm(probs, 0.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rlnorm(20, 0.0, 1.0); 

// Scalar Returns
double dval  = R::dlnorm(0.25, 0.0, 1.0, false);
double pval  = R::plnorm(0.5, 0.0, 1.0, true, false);
double qval  = R::qlnorm(0.0452, 0.0, 1.0, true, false);
double rdraw = R::rlnorm(0.0, 1.0);
```

### Logistic Distribution {#logistic-dist}

|                                                   |
|:--------------------------------------------------|
| **dlogis(X, LOCATION, SCALE, LOG_P)**             |
| **plogis(Q, LOCATION, SCALE, LOWER_TAIL, LOG_P)** |
| **qlogis(P, LOCATION, SCALE, LOWER_TAIL, LOG_P)** |
| **rlogis(N, LOCATION, SCALE)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Logistic distribution.
  
- When simulating a vector or scalar from a Logistic distribution, the value returned
  is within $\left(-\infty,\infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOCATION = 0`, the shift component of the distribution
    - `SCALE = 1`, the dispersion parameter of the distribution that changes the spread e.g. if the SCALE is small, then the distribution is concentrated.
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:
 
```{Rcpp rcpp_logis_dist}
// Consider X ~ Logis(0, 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dlogis(xx, 0.0, 1.0, false);
NumericVector probs     = Rcpp::plogis(xx, 0.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qlogis(probs, 0.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rlogis(20, 0.0, 1.0); 

// Scalar Returns
double dval  = R::dlogis(0.25, 0.0, 1.0, false);
double pval  = R::plogis(0.5, 0.0, 1.0, true, false);
double qval  = R::qlogis(0.0452, 0.0, 1.0, true, false);
double rdraw = R::rlogis(0.0, 1.0);
```


### Student's T Distribution {#t-dist}

**rt()**

### Uniform Distribution {#unif-dist}

**runif()**

### Weibull Distribution {#weibull-dist}

**rweibull()**

# Appendix


## RTYPES

| RTYPE |  SEXPTYPE    |	Description                                              |
|:------|:-------------|:----------------------------------------------------------|	
| 0     | `NILSXP`     | `NULL`                                                    |
| 1     | `SYMSXP`     | symbols                                                   |
| 2     | `LISTSXP`    | pairlists                                                 |
| 3     | `CLOSXP`     | closures                                                  |
| 4     | `ENVSXP`     | environments                                              |
| 5     | `PROMSXP`    | promises                                                  |
| 6     | `LANGSXP`    | language objects                                          |
| 7     | `SPECIALSXP` | special functions                                         |
| 8     | `BUILTINSXP` | builtin functions                                         |
| 9     | `CHARSXP`    | internal character strings                                |
| 10    | `LGLSXP`     | `logical` vectors                                         |
| 13    | `INTSXP`     | `integer` vectors                                         |
| 14    | `REALSXP`    | `numeric` vectors                                         |
| 15    | `CPLXSXP`    | `complex` vectors                                         |
| 16    | `STRSXP`     | `character` vectors                                       |
| 17    | `DOTSXP`     | dot-dot-dot object                                        |
| 18    | `ANYSXP`     | make "any" args work                                      |
| 19    | `VECSXP`     | `list` (`generic` vector)                                 |
| 20    | `EXPRSXP`    | `expression` vector                                       |
| 21    | `BCODESXP`   | byte code                                                 |
| 22    | `EXTPTRSXP`  | external pointer                                          |
| 23    | `WEAKREFSXP` | weak reference                                            |
| 24    | `RAWSXP`     | `raw` vector                                              |
| 25    | `S4SXP`      | `S4` classes not of simple type                           |
| 99    | `FUNSXP`     | functions of type `CLOSXP`, `SPECIALSXP` and `BUILTINSXP` |

- See also:
    - [SEXPTYPEs on the official R Release documentation](https://cran.r-project.org/doc/manuals/r-release/R-ints.html#SEXPTYPEs)
    - [The data types explained on the official R Release documentation](https://cran.r-project.org/doc/manuals/r-release/R-ints.html#The-_0027data_0027)

